<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>multidevice.dev_kodi.device API documentation</title>
<meta name="description" content="Device class for Kodi Mediacenter â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>multidevice.dev_kodi.device</code></h1>
</header>
<section id="section-intro">
<p>Device class for Kodi Mediacenter.</p>
<p>This is a bit more complex than e.g. the Pioneer/Denon family device classes.</p>
<p>Complex response or notification datagrams with multiple data points can not
easily - and usefully - be crammed into a single item, so we need a logic to
separate the data points and split them into different items (better: command
responses). This is mostly handled in <code>on_data_received()</code>.</p>
<p>Due to multiple device namespaces, some responses require us to ask for
additional specific information from the device. This is handled by
<code>send_command()</code> and <code>_update_status()</code>.</p>
<p>The "special" (a.k.a. fake) commands (as they are not a single command to send
to the device) have to be recognized, so we also tamper with <code>is_valid_command()</code>.</p>
<p>NOTE: quite some of the logic in <code>on_data_received()</code>, especially most of the
code for handling notifications could be achieved by adding complex commands
which control the <code>playpause</code> and <code>stop</code> command; the dependent settings
could then be accomplished by more or less complex item and eval constructs.</p>
<pre><code>  As this is - foremost - a port of the kodi plugin and a demonstrator for
  how to and how not to use the MultiDevice capabilities, I've not yet changed
  much.

  Any complexity moved out of the &lt;code&gt;device.py&lt;/code&gt; code will need to find another
  place, in &lt;code&gt;commands.py&lt;/code&gt; and/or the item configuration.
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# vim: set encoding=utf-8 tabstop=4 softtabstop=4 shiftwidth=4 expandtab

&#39;&#39;&#39;
Device class for Kodi Mediacenter.

This is a bit more complex than e.g. the Pioneer/Denon family device classes.

Complex response or notification datagrams with multiple data points can not
easily - and usefully - be crammed into a single item, so we need a logic to
separate the data points and split them into different items (better: command
responses). This is mostly handled in ``on_data_received()``.

Due to multiple device namespaces, some responses require us to ask for
additional specific information from the device. This is handled by
``send_command()`` and ``_update_status()``.

The &#34;special&#34; (a.k.a. fake) commands (as they are not a single command to send
to the device) have to be recognized, so we also tamper with ``is_valid_command()``.

NOTE: quite some of the logic in ``on_data_received()``, especially most of the
      code for handling notifications could be achieved by adding complex commands
      which control the ``playpause`` and ``stop`` command; the dependent settings
      could then be accomplished by more or less complex item and eval constructs.

      As this is - foremost - a port of the kodi plugin and a demonstrator for
      how to and how not to use the MultiDevice capabilities, I&#39;ve not yet changed
      much.

      Any complexity moved out of the ``device.py`` code will need to find another
      place, in ``commands.py`` and/or the item configuration.
&#39;&#39;&#39;

if MD_standalone:
    from MD_Globals import *
    from MD_Device import MD_Device
    from MD_Command import MD_Command_JSON
    from MD_Protocol import MD_Protocol_Jsonrpc
else:
    from ..MD_Globals import *
    from ..MD_Device import MD_Device
    from ..MD_Command import MD_Command_JSON
    from ..MD_Protocol import MD_Protocol_Jsonrpc

import logging


class MD_Device(MD_Device):

    def __init__(self, device_type, device_id, **kwargs):

        # get MultiDevice.device logger
        self.logger = logging.getLogger(&#39;.&#39;.join(__name__.split(&#39;.&#39;)[:-2]) + f&#39;.{device_id}&#39;)

        # set parameter defaults
        self._params = {&#39;command_class&#39;: MD_Command_JSON, 
                        PLUGIN_ARG_PROTOCOL: PROTO_JSONRPC,
                        PLUGIN_ARG_CONNECTION: CONN_NET_TCP_CLI,
                        PLUGIN_ARG_NET_HOST: &#39;&#39;, 
                        PLUGIN_ARG_NET_PORT: 9090, 
                        PLUGIN_ARG_AUTORECONNECT: True,
                        PLUGIN_ARG_CONN_RETRIES: 5, 
                        PLUGIN_ARG_CONN_CYCLE: 3, 
                        PLUGIN_ARG_TIMEOUT: 3, 
                        PLUGIN_ARG_MSG_REPEAT: 3,
                        PLUGIN_ARG_MSG_TIMEOUT: 5,
                        PLUGIN_ARG_CB_ON_CONNECT: self.on_connect,
                        PLUGIN_ARG_CB_ON_DISCONNECT: self.on_disconnect}

        super().__init__(device_type, device_id, **kwargs)

        if not self.disabled:

            self._activeplayers = []
            self._playerid = 0

            # these commands are not meant to control the kodi device, but to
            # communicate with the device class, e.g. triggering updating player
            # info or returning the player_id.
            # As these commands are not sent (directly) to the device, they should
            # not be processed via the MD_Commands class and not listed in commands.py
            self._special_commands = {&#39;read&#39;: [&#39;player&#39;], &#39;write&#39;: [&#39;update&#39;]}

            # log own initialization with module (i.e. folder) name
            self.logger.debug(f&#39;device initialized from {__spec__.name} with arguments {kwargs}&#39;)

#
# further overloaded methods
#

    def on_connect(self, by=None):
        super().on_connect(by)
        self._update_status()

    def on_data_received(self, by, data, command=None):
        &#39;&#39;&#39;
        Callback function for received data e.g. from an event loop
        Processes data and dispatches value to plugin class

        :param command: the command in reply to which data was received
        :param data: received data in &#39;raw&#39; connection format
        :type command: str
        &#39;&#39;&#39;
        if command is not None:
            self.logger.debug(f&#39;received data &#34;{data}&#34; for command {command}&#39;)
        else:
            self.logger.debug(f&#39;data &#34;{data}&#34; did not identify a known command&#39;)

        if not self._data_received_callback:
            self.logger.error(&#39;on_data_received callback not set, can not process device reply data, ignoring it&#39;)
            return

        if not isinstance(data, dict):
            self.logger.error(f&#39;received data {data} not in JSON (dict) format, ignoring&#39;)

        if &#39;error&#39; in data:
            # errors are handled on connection level
            return

        try:
            result_data = data.get(&#39;result&#39;)
        except Exception as e:
            self.logger.error(f&#39;Invalid response to command {command} received: {data}, ignoring. Error was: {e}&#39;)
            return
        if &#39;id&#39; in data and result_data is None:
            self.logger.info(f&#39;Empty response to command {command} received, ignoring&#39;)
            return

        query_playerinfo = []

        processed = False

        # replies to requests sent by us
        if &#39;id&#39; in data:
            if command == &#39;Player.GetActivePlayers&#39;:
                processed = True
                if len(result_data) == 1:
                    # one active player
                    query_playerinfo = self._activeplayers = [result_data[0].get(&#39;playerid&#39;)]
                    self._playerid = self._activeplayers[0]
                    self.logger.debug(f&#39;received GetActivePlayers, set playerid to {self._playerid}&#39;)
                    self._data_received_callback(self.device_id, &#39;player&#39;, self._playerid)
                    self._data_received_callback(self.device_id, &#39;media&#39;, result_data[0].get(&#39;type&#39;).capitalize())
                elif len(result_data) &gt; 1:
                    # multiple active players. Have not yet seen this happen
                    self._activeplayers = []
                    for player in result_data:
                        self._activeplayers.append(player.get(&#39;playerid&#39;))
                        query_playerinfo.append(player.get(&#39;playerid&#39;))
                    self._playerid = min(self._activeplayers)
                    self.logger.debug(f&#39;received GetActivePlayers, set playerid to {self._playerid}&#39;)
                else:
                    # no active players
                    self._activeplayers = []
                    self._data_received_callback(self.device_id, &#39;state&#39;, &#39;No active player&#39;)
                    self._data_received_callback(self.device_id, &#39;player&#39;, 0)
                    self._data_received_callback(self.device_id, &#39;title&#39;, &#39;&#39;)
                    self._data_received_callback(self.device_id, &#39;media&#39;, &#39;&#39;)
                    self._data_received_callback(self.device_id, &#39;stop&#39;, True)
                    self._data_received_callback(self.device_id, &#39;playpause&#39;, False)
                    self._data_received_callback(self.device_id, &#39;streams&#39;, None)
                    self._data_received_callback(self.device_id, &#39;subtitles&#39;, None)
                    self._data_received_callback(self.device_id, &#39;audio&#39;, &#39;&#39;)
                    self._data_received_callback(self.device_id, &#39;subtitle&#39;, &#39;&#39;)
                    self._playerid = 0
                    self.logger.debug(&#39;received GetActivePlayers, reset playerid to 0&#39;)

            # got status info
            elif command == &#39;Application.GetProperties&#39;:
                processed = True
                muted = result_data.get(&#39;muted&#39;)
                volume = result_data.get(&#39;volume&#39;)
                self.logger.debug(f&#39;received GetProperties: change mute to {muted} and volume to {volume}&#39;)
                self._data_received_callback(self.device_id, &#39;mute&#39;, muted)
                self._data_received_callback(self.device_id, &#39;volume&#39;, volume)

            # got favourites
            elif command == &#39;Favourites.GetFavourites&#39;:
                processed = True
                if not result_data.get(&#39;favourites&#39;):
                    self.logger.debug(&#39;No favourites found.&#39;)
                else:
                    item_dict = {item[&#39;title&#39;]: item for item in result_data.get(&#39;favourites&#39;)}
                    self.logger.debug(f&#39;favourites found: {item_dict}&#39;)
                    self._data_received_callback(self.device_id, &#39;get_favourites&#39;, item_dict)

            # got item info
            elif command == &#39;Player.GetItem&#39;:
                processed = True
                title = result_data[&#39;item&#39;].get(&#39;title&#39;)
                player_type = result_data[&#39;item&#39;].get(&#39;type&#39;)
                if not title:
                    title = result_data[&#39;item&#39;].get(&#39;label&#39;)
                self._data_received_callback(self.device_id, &#39;media&#39;, player_type.capitalize())
                if player_type == &#39;audio&#39; and &#39;artist&#39; in result_data[&#39;item&#39;]:
                    artist = &#39;unknown&#39; if len(result_data[&#39;item&#39;].get(&#39;artist&#39;)) == 0 else result_data[&#39;item&#39;].get(&#39;artist&#39;)[0]
                    title = artist + &#39; - &#39; + title
                if title:
                    self._data_received_callback(self.device_id, &#39;title&#39;, title)
                self.logger.debug(f&#39;received GetItem: update player info to title={title}, type={player_type}&#39;)

            # got player status
            elif command == &#39;Player.GetProperties&#39;:
                processed = True
                self.logger.debug(&#39;Received Player.GetProperties, update media data&#39;)
                self._data_received_callback(self.device_id, &#39;speed&#39;, result_data.get(&#39;speed&#39;))
                self._data_received_callback(self.device_id, &#39;seek&#39;, result_data.get(&#39;percentage&#39;))
                self._data_received_callback(self.device_id, &#39;streams&#39;, result_data.get(&#39;audiostreams&#39;))
                self._data_received_callback(self.device_id, &#39;audio&#39;, result_data.get(&#39;currentaudiostream&#39;))
                self._data_received_callback(self.device_id, &#39;subtitles&#39;, result_data.get(&#39;subtitles&#39;))
                if result_data.get(&#39;subtitleenabled&#39;):
                    subtitle = result_data.get(&#39;currentsubtitle&#39;)
                else:
                    subtitle = &#39;Off&#39;
                self._data_received_callback(self.device_id, &#39;subtitle&#39;, subtitle)

                # speed != 0 -&gt; play; speed == 0 -&gt; pause
                if result_data.get(&#39;speed&#39;) == 0:
                    self._data_received_callback(self.device_id, &#39;state&#39;, &#39;Paused&#39;)
                    self._data_received_callback(self.device_id, &#39;stop&#39;, False)
                    self._data_received_callback(self.device_id, &#39;playpause&#39;, False)
                else:
                    self._data_received_callback(self.device_id, &#39;state&#39;, &#39;Playing&#39;)
                    self._data_received_callback(self.device_id, &#39;stop&#39;, False)
                    self._data_received_callback(self.device_id, &#39;playpause&#39;, True)

        # not replies, but event notifications.
        elif &#39;method&#39; in data:

            # no id, notification or other
            if data[&#39;method&#39;] == &#39;Player.OnResume&#39;:
                processed = True
                self.logger.debug(&#39;received: resumed player&#39;)
                self._data_received_callback(self.device_id, &#39;state&#39;, &#39;Playing&#39;)
                self._data_received_callback(self.device_id, &#39;stop&#39;, False)
                self._data_received_callback(self.device_id, &#39;playpause&#39;, True)
                query_playerinfo.append(data[&#39;params&#39;][&#39;data&#39;][&#39;player&#39;][&#39;playerid&#39;])

            elif data[&#39;method&#39;] == &#39;Player.OnPause&#39;:
                processed = True
                self.logger.debug(&#39;received: paused player&#39;)
                self._data_received_callback(self.device_id, &#39;state&#39;, &#39;Paused&#39;)
                self._data_received_callback(self.device_id, &#39;stop&#39;, False)
                self._data_received_callback(self.device_id, &#39;playpause&#39;, False)
                query_playerinfo.append(data[&#39;params&#39;][&#39;data&#39;][&#39;player&#39;][&#39;playerid&#39;])

            elif data[&#39;method&#39;] == &#39;Player.OnStop&#39;:
                processed = True
                self.logger.debug(&#39;received: stopped player, set playerid to 0&#39;)
                self._data_received_callback(self.device_id, &#39;state&#39;, &#39;No active player&#39;)
                self._data_received_callback(self.device_id, &#39;media&#39;, &#39;&#39;)
                self._data_received_callback(self.device_id, &#39;title&#39;, &#39;&#39;)
                self._data_received_callback(self.device_id, &#39;player&#39;, 0)
                self._data_received_callback(self.device_id, &#39;stop&#39;, True)
                self._data_received_callback(self.device_id, &#39;playpause&#39;, False)
                self._data_received_callback(self.device_id, &#39;streams&#39;, None)
                self._data_received_callback(self.device_id, &#39;subtitles&#39;, None)
                self._data_received_callback(self.device_id, &#39;audio&#39;, &#39;&#39;)
                self._data_received_callback(self.device_id, &#39;subtitle&#39;, &#39;&#39;)
                self._activeplayers = []
                self._playerid = 0

            elif data[&#39;method&#39;] == &#39;GUI.OnScreensaverActivated&#39;:
                processed = True
                self.logger.debug(&#39;received: activated screensaver&#39;)
                self._data_received_callback(self.device_id, &#39;state&#39;, &#39;Screensaver&#39;)

            elif data[&#39;method&#39;][:9] == &#39;Player.On&#39;:
                processed = True
                self.logger.debug(&#39;received: player notification&#39;)
                try:
                    p_id = data[&#39;params&#39;][&#39;data&#39;][&#39;player&#39;][&#39;playerid&#39;]
                    query_playerinfo.append(p_id)
                except KeyError:
                    pass

                try:
                    self._data_received_callback(self.device_id, &#39;media&#39;, data[&#39;params&#39;][&#39;data&#39;][&#39;item&#39;][&#39;channeltype&#39;])
                    self._data_received_callback(self.device_id, &#39;title&#39;, data[&#39;params&#39;][&#39;data&#39;][&#39;item&#39;][&#39;title&#39;])
                except KeyError:
                    pass

            elif data[&#39;method&#39;] == &#39;Application.OnVolumeChanged&#39;:
                processed = True
                self.logger.debug(&#39;received: volume changed, got new values mute: {} and volume: {}&#39;.format(data[&#39;params&#39;][&#39;data&#39;][&#39;muted&#39;], data[&#39;params&#39;][&#39;data&#39;][&#39;volume&#39;]))
                self._data_received_callback(self.device_id, &#39;mute&#39;, data[&#39;params&#39;][&#39;data&#39;][&#39;muted&#39;])
                self._data_received_callback(self.device_id, &#39;volume&#39;, data[&#39;params&#39;][&#39;data&#39;][&#39;volume&#39;])

        # if active playerid(s) was changed, update status for active player(s)
        if query_playerinfo:
            self.logger.debug(f&#39;player info query requested for playerid(s) {query_playerinfo}&#39;)
            for player_id in set(query_playerinfo):
                self.logger.debug(f&#39;getting player info for player #{player_id}&#39;)
                self._connection._send_rpc_message(&#39;Player.GetItem&#39;, {&#39;properties&#39;: [&#39;title&#39;, &#39;artist&#39;], &#39;playerid&#39;: player_id})
                self._connection._send_rpc_message(&#39;Player.GetProperties&#39;, {&#39;properties&#39;: [&#39;speed&#39;, &#39;percentage&#39;, &#39;currentaudiostream&#39;, &#39;audiostreams&#39;, &#39;subtitleenabled&#39;, &#39;currentsubtitle&#39;, &#39;subtitles&#39;], &#39;playerid&#39;: player_id})

        if processed:
            return

        # if we reach this point, no special handling case was detected, so just go on normally...

        try:
            # try and transform the JSON RPC method into the matching command
            command = self._commands.get_command_from_reply(command)
            value = self._commands.get_shng_data(command, data)
        except Exception as e:
            self.logger.info(f&#39;received data &#34;{data}&#34; for command {command}, error occurred while converting. Discarding data. Error was: {e}&#39;)
            return

        # pass on data for regular item assignment
        self.logger.debug(f&#39;received data &#34;{data}&#34; for command {command} converted to value {value}&#39;)
        self._data_received_callback(self.device_id, command, value)

    def send_command(self, command, value=None, **kwargs):
        &#39;&#39;&#39;
        Checks for special commands and handles them, otherwise call the
        base class&#39; method

        :param command: the command to send
        :param value: the data to send, if applicable
        :type command: str
        :return: True if send was successful, False otherwise
        :rtype: bool
        &#39;&#39;&#39;
        if not self.alive:
            self.logger.warning(f&#39;trying to send command {command} with value {value}, but device is not active.&#39;)
            return False

        if not self._connection:
            self.logger.warning(f&#39;trying to send command {command} with value {value}, but connection is None. This shouldn\&#39;t happen...&#39;)
            return False

        if not self._connection.connected:
            self._connection.open()
            if not self._connection.connected:
                self.logger.warning(f&#39;trying to send command {command} with value {value}, but connection could not be established.&#39;)
                return False

        if command in self._special_commands[&#39;read&#39; if value is None else &#39;write&#39;]:
            if command == &#39;update&#39;:
                if value:
                    self._update_status()
                return True
            elif value is None:
                self.logger.debug(f&#39;Special command {command} called for reading, which is not intended. Ignoring request&#39;)
                return True
            else:
                # this shouldn&#39;t happen
                self.logger.warning(f&#39;Special command {command} found, no action set for processing. Please inform developers. Ignoring request&#39;)
                return True
        else:
            return super().send_command(command, value, playerid=self._playerid, **kwargs)

    def is_valid_command(self, command, read=None):
        &#39;&#39;&#39;
        In addition to base class method, allow &#39;special&#39;
        commands not defined in commands.py which are meant
        to control the plugin device, e.g. &#39;update&#39; to read
        player status.
        If not special command, call base class method

        :param command: the command to test
        :type command: str
        :param read: check for read (True) or write (False), or both (None)
        :type read: bool | NoneType
        :return: True if command is valid, False otherwise
        :rtype: bool
        &#39;&#39;&#39;
        if command in self._special_commands[&#39;read&#39; if read else &#39;write&#39;]:
            self.logger.debug(f&#39;Acknowledging special command {command}, read is {read}&#39;)
            return True
        else:
            return super().is_valid_command(command, read)

#
# new methods
#

    def notify(self, title, message, image=None, display_time=10000):
        &#39;&#39;&#39;
        Send a notification to Kodi to be displayed on the screen

        :param title: the title of the message
        :param message: the message itself
        :param image: an optional image to be displayed alongside the message
        :param display_time: how long the message is displayed in milli seconds
        &#39;&#39;&#39;
        params = {&#39;title&#39;: title, &#39;message&#39;: message, &#39;displaytime&#39;: display_time}
        if image is not None:
            params[&#39;image&#39;] = image
        self._connection._send_rpc_message(&#39;GUI.ShowNotification&#39;, params)

    def _update_status(self):
        &#39;&#39;&#39;
        This method requests several status infos
        &#39;&#39;&#39;
        if self.alive:
            self.send_command(&#39;get_actplayer&#39;, None)
            self.send_command(&#39;get_status_au&#39;, None)
            if self._playerid:
                self.send_command(&#39;get_status_play&#39;, None)
                self.send_command(&#39;get_item&#39;, None)

    # def _check_commands_data(self):
    #     &#39;&#39;&#39;
    #     Method checks consistency of imported commands data
# 
    #     This is ported directly from the old kodi plugin; to not clutter things
    #     this method is implemented in the device class, even though it works
    #     on the commands and should have been implemented there. But overloading
    #     the commands class is not something (yet) planned...
# 
    #     :return: True if data is consistent
    #     :rtype: bool
    #     &#39;&#39;&#39;
    #     no_method = []
    #     wrong_keys = []
    #     unmatched = []
    #     bounds = []
    #     values = []
    #     for command, cmd_obj in self._commands._commands.items():
# 
    #         if not cmd_obj:
    #             print(f&#39;no obj: {cmd_obj}&#39;)
    #             
    #         # verify all keys are present
    #         if not [&#39;method&#39;, &#39;set&#39;, &#39;get&#39;, &#39;params&#39;, &#39;values&#39;, &#39;bounds&#39;].sort() == list(entry.keys()).sort():
    #             wrong_keys.append(command)
    #         elif not [&#39;set&#39;, &#39;special&#39;].sort() == list(entry.keys()).sort():
    #             # check that method is not empty
    #             if not entry[&#39;method&#39;]:
    #                 no_method.append(command)
    #             par = entry[&#39;params&#39;]
    #             val = entry[&#39;values&#39;]
    #             bnd = entry[&#39;bounds&#39;]
    #             # params and values must be either both None or both lists of equal length
    #             if par is None and val is not None or par is not None and val is None:
    #                 unmatched.append(command)
    #             elif par is not None and val is not None and len(par) != len(val):
    #                 unmatched.append(command)
    #             vals = 0
    #             if val is not None:
    #                 # check that max. one &#39;VAL&#39; entry is present
    #                 for item in val:
    #                     if item == &#39;VAL&#39;:
    #                         vals += 1
    #                 if vals &gt; 1:
    #                     values.append(command)
    #             # check that bounds are None or list or (tuple and len(bounds)=2)
    #             if bnd is not None and \
    #                not isinstance(bnd, list) and \
    #                (not (isinstance(bnd, tuple) and len(bnd) == 2)):
    #                 bounds.append(command)
    #             # check that bounds are only defined if &#39;VAL&#39; is present
    #             if vals == 0 and bnd is not None:
    #                 bounds.append(command)
# 
    #     # found any errors?
    #     if len(no_method + wrong_keys + unmatched + bounds + values) &gt; 0:
    #         if len(wrong_keys) &gt; 0:
    #             self.logger.error(&#39;Commands data not consistent: commands &#34;&#39; + &#39;&#34;, &#34;&#39;.join(wrong_keys) + &#39;&#34; have wrong keys&#39;)
    #         if len(no_method) &gt; 0:
    #             self.logger.error(&#39;Commands data not consistent: commands &#34;&#39; + &#39;&#34;, &#34;&#39;.join(no_method) + &#39;&#34; have no method&#39;)
    #         if len(unmatched) &gt; 0:
    #             self.logger.error(&#39;Commands data not consistent: commands &#34;&#39; + &#39;&#34;, &#34;&#39;.join(unmatched) + &#39;&#34; have unmatched params/values&#39;)
    #         if len(bounds) &gt; 0:
    #             self.logger.error(&#39;Commands data not consistent: commands &#34;&#39; + &#39;&#34;, &#34;&#39;.join(bounds) + &#39;&#34; have erroneous bounds&#39;)
    #         if len(values) &gt; 0:
    #             self.logger.error(&#39;Commands data not consistent: commands &#34;&#39; + &#39;&#34;, &#34;&#39;.join(values) + &#39;&#34; have more than one &#34;VAL&#34; field&#39;)
# 
    #         return False
# 
    #     macros = []
    #     for macro, entry in commands.macros.items():
    #         if not isinstance(entry, list):
    #             macros.append(macro)
    #         else:
    #             for step in entry:
    #                 if not isinstance(step, list) or len(step) != 2:
    #                     macros.append(macro)
# 
    #     if len(macros) &gt; 0:
    #         self.logger.error(&#39;Macro data not consistent for macros &#34;&#39; + &#39;&#34;, &#34;&#39;.join(macros) + &#39;&#34;&#39;)
    #         # errors in macro definition don&#39;t hinder normal plugin functionality, so just
    #         # refill self._MACRO omitting erroneous entries. With bad luck, _MACRO is empty ;)
    #         self._MACRO = {}
    #         for command, entry in command.macros:
    #             if command not in macros:
    #                 self._MACRO[command] = entry
# 
    #     return True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="multidevice.dev_kodi.device.MD_Device"><code class="flex name class">
<span>class <span class="ident">MD_Device</span></span>
<span>(</span><span>device_type, device_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is the base class for a simple device class. It can process commands
by sending values to the device and collect data by parsing data received from
the device.</p>
<p>Configuration is done via dev_<device_type>/commands.py (see dev_example for format)</p>
<p>:param device_type: device type as used in derived class names
:param device_id: device id for use in item configuration and logs
:type device_type: str
:type device_id: str</p>
<p>This initializes the class object.</p>
<p>As additional device classes are expected to be implemented as subclasses,
most initialization steps are modularized as methods which can be overloaded
as needed.
As all pre-implemented methods are called in hopefully-logical sequence,
this <strong>init</strong> probably doesn't need to be changed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MD_Device(MD_Device):

    def __init__(self, device_type, device_id, **kwargs):

        # get MultiDevice.device logger
        self.logger = logging.getLogger(&#39;.&#39;.join(__name__.split(&#39;.&#39;)[:-2]) + f&#39;.{device_id}&#39;)

        # set parameter defaults
        self._params = {&#39;command_class&#39;: MD_Command_JSON, 
                        PLUGIN_ARG_PROTOCOL: PROTO_JSONRPC,
                        PLUGIN_ARG_CONNECTION: CONN_NET_TCP_CLI,
                        PLUGIN_ARG_NET_HOST: &#39;&#39;, 
                        PLUGIN_ARG_NET_PORT: 9090, 
                        PLUGIN_ARG_AUTORECONNECT: True,
                        PLUGIN_ARG_CONN_RETRIES: 5, 
                        PLUGIN_ARG_CONN_CYCLE: 3, 
                        PLUGIN_ARG_TIMEOUT: 3, 
                        PLUGIN_ARG_MSG_REPEAT: 3,
                        PLUGIN_ARG_MSG_TIMEOUT: 5,
                        PLUGIN_ARG_CB_ON_CONNECT: self.on_connect,
                        PLUGIN_ARG_CB_ON_DISCONNECT: self.on_disconnect}

        super().__init__(device_type, device_id, **kwargs)

        if not self.disabled:

            self._activeplayers = []
            self._playerid = 0

            # these commands are not meant to control the kodi device, but to
            # communicate with the device class, e.g. triggering updating player
            # info or returning the player_id.
            # As these commands are not sent (directly) to the device, they should
            # not be processed via the MD_Commands class and not listed in commands.py
            self._special_commands = {&#39;read&#39;: [&#39;player&#39;], &#39;write&#39;: [&#39;update&#39;]}

            # log own initialization with module (i.e. folder) name
            self.logger.debug(f&#39;device initialized from {__spec__.name} with arguments {kwargs}&#39;)

#
# further overloaded methods
#

    def on_connect(self, by=None):
        super().on_connect(by)
        self._update_status()

    def on_data_received(self, by, data, command=None):
        &#39;&#39;&#39;
        Callback function for received data e.g. from an event loop
        Processes data and dispatches value to plugin class

        :param command: the command in reply to which data was received
        :param data: received data in &#39;raw&#39; connection format
        :type command: str
        &#39;&#39;&#39;
        if command is not None:
            self.logger.debug(f&#39;received data &#34;{data}&#34; for command {command}&#39;)
        else:
            self.logger.debug(f&#39;data &#34;{data}&#34; did not identify a known command&#39;)

        if not self._data_received_callback:
            self.logger.error(&#39;on_data_received callback not set, can not process device reply data, ignoring it&#39;)
            return

        if not isinstance(data, dict):
            self.logger.error(f&#39;received data {data} not in JSON (dict) format, ignoring&#39;)

        if &#39;error&#39; in data:
            # errors are handled on connection level
            return

        try:
            result_data = data.get(&#39;result&#39;)
        except Exception as e:
            self.logger.error(f&#39;Invalid response to command {command} received: {data}, ignoring. Error was: {e}&#39;)
            return
        if &#39;id&#39; in data and result_data is None:
            self.logger.info(f&#39;Empty response to command {command} received, ignoring&#39;)
            return

        query_playerinfo = []

        processed = False

        # replies to requests sent by us
        if &#39;id&#39; in data:
            if command == &#39;Player.GetActivePlayers&#39;:
                processed = True
                if len(result_data) == 1:
                    # one active player
                    query_playerinfo = self._activeplayers = [result_data[0].get(&#39;playerid&#39;)]
                    self._playerid = self._activeplayers[0]
                    self.logger.debug(f&#39;received GetActivePlayers, set playerid to {self._playerid}&#39;)
                    self._data_received_callback(self.device_id, &#39;player&#39;, self._playerid)
                    self._data_received_callback(self.device_id, &#39;media&#39;, result_data[0].get(&#39;type&#39;).capitalize())
                elif len(result_data) &gt; 1:
                    # multiple active players. Have not yet seen this happen
                    self._activeplayers = []
                    for player in result_data:
                        self._activeplayers.append(player.get(&#39;playerid&#39;))
                        query_playerinfo.append(player.get(&#39;playerid&#39;))
                    self._playerid = min(self._activeplayers)
                    self.logger.debug(f&#39;received GetActivePlayers, set playerid to {self._playerid}&#39;)
                else:
                    # no active players
                    self._activeplayers = []
                    self._data_received_callback(self.device_id, &#39;state&#39;, &#39;No active player&#39;)
                    self._data_received_callback(self.device_id, &#39;player&#39;, 0)
                    self._data_received_callback(self.device_id, &#39;title&#39;, &#39;&#39;)
                    self._data_received_callback(self.device_id, &#39;media&#39;, &#39;&#39;)
                    self._data_received_callback(self.device_id, &#39;stop&#39;, True)
                    self._data_received_callback(self.device_id, &#39;playpause&#39;, False)
                    self._data_received_callback(self.device_id, &#39;streams&#39;, None)
                    self._data_received_callback(self.device_id, &#39;subtitles&#39;, None)
                    self._data_received_callback(self.device_id, &#39;audio&#39;, &#39;&#39;)
                    self._data_received_callback(self.device_id, &#39;subtitle&#39;, &#39;&#39;)
                    self._playerid = 0
                    self.logger.debug(&#39;received GetActivePlayers, reset playerid to 0&#39;)

            # got status info
            elif command == &#39;Application.GetProperties&#39;:
                processed = True
                muted = result_data.get(&#39;muted&#39;)
                volume = result_data.get(&#39;volume&#39;)
                self.logger.debug(f&#39;received GetProperties: change mute to {muted} and volume to {volume}&#39;)
                self._data_received_callback(self.device_id, &#39;mute&#39;, muted)
                self._data_received_callback(self.device_id, &#39;volume&#39;, volume)

            # got favourites
            elif command == &#39;Favourites.GetFavourites&#39;:
                processed = True
                if not result_data.get(&#39;favourites&#39;):
                    self.logger.debug(&#39;No favourites found.&#39;)
                else:
                    item_dict = {item[&#39;title&#39;]: item for item in result_data.get(&#39;favourites&#39;)}
                    self.logger.debug(f&#39;favourites found: {item_dict}&#39;)
                    self._data_received_callback(self.device_id, &#39;get_favourites&#39;, item_dict)

            # got item info
            elif command == &#39;Player.GetItem&#39;:
                processed = True
                title = result_data[&#39;item&#39;].get(&#39;title&#39;)
                player_type = result_data[&#39;item&#39;].get(&#39;type&#39;)
                if not title:
                    title = result_data[&#39;item&#39;].get(&#39;label&#39;)
                self._data_received_callback(self.device_id, &#39;media&#39;, player_type.capitalize())
                if player_type == &#39;audio&#39; and &#39;artist&#39; in result_data[&#39;item&#39;]:
                    artist = &#39;unknown&#39; if len(result_data[&#39;item&#39;].get(&#39;artist&#39;)) == 0 else result_data[&#39;item&#39;].get(&#39;artist&#39;)[0]
                    title = artist + &#39; - &#39; + title
                if title:
                    self._data_received_callback(self.device_id, &#39;title&#39;, title)
                self.logger.debug(f&#39;received GetItem: update player info to title={title}, type={player_type}&#39;)

            # got player status
            elif command == &#39;Player.GetProperties&#39;:
                processed = True
                self.logger.debug(&#39;Received Player.GetProperties, update media data&#39;)
                self._data_received_callback(self.device_id, &#39;speed&#39;, result_data.get(&#39;speed&#39;))
                self._data_received_callback(self.device_id, &#39;seek&#39;, result_data.get(&#39;percentage&#39;))
                self._data_received_callback(self.device_id, &#39;streams&#39;, result_data.get(&#39;audiostreams&#39;))
                self._data_received_callback(self.device_id, &#39;audio&#39;, result_data.get(&#39;currentaudiostream&#39;))
                self._data_received_callback(self.device_id, &#39;subtitles&#39;, result_data.get(&#39;subtitles&#39;))
                if result_data.get(&#39;subtitleenabled&#39;):
                    subtitle = result_data.get(&#39;currentsubtitle&#39;)
                else:
                    subtitle = &#39;Off&#39;
                self._data_received_callback(self.device_id, &#39;subtitle&#39;, subtitle)

                # speed != 0 -&gt; play; speed == 0 -&gt; pause
                if result_data.get(&#39;speed&#39;) == 0:
                    self._data_received_callback(self.device_id, &#39;state&#39;, &#39;Paused&#39;)
                    self._data_received_callback(self.device_id, &#39;stop&#39;, False)
                    self._data_received_callback(self.device_id, &#39;playpause&#39;, False)
                else:
                    self._data_received_callback(self.device_id, &#39;state&#39;, &#39;Playing&#39;)
                    self._data_received_callback(self.device_id, &#39;stop&#39;, False)
                    self._data_received_callback(self.device_id, &#39;playpause&#39;, True)

        # not replies, but event notifications.
        elif &#39;method&#39; in data:

            # no id, notification or other
            if data[&#39;method&#39;] == &#39;Player.OnResume&#39;:
                processed = True
                self.logger.debug(&#39;received: resumed player&#39;)
                self._data_received_callback(self.device_id, &#39;state&#39;, &#39;Playing&#39;)
                self._data_received_callback(self.device_id, &#39;stop&#39;, False)
                self._data_received_callback(self.device_id, &#39;playpause&#39;, True)
                query_playerinfo.append(data[&#39;params&#39;][&#39;data&#39;][&#39;player&#39;][&#39;playerid&#39;])

            elif data[&#39;method&#39;] == &#39;Player.OnPause&#39;:
                processed = True
                self.logger.debug(&#39;received: paused player&#39;)
                self._data_received_callback(self.device_id, &#39;state&#39;, &#39;Paused&#39;)
                self._data_received_callback(self.device_id, &#39;stop&#39;, False)
                self._data_received_callback(self.device_id, &#39;playpause&#39;, False)
                query_playerinfo.append(data[&#39;params&#39;][&#39;data&#39;][&#39;player&#39;][&#39;playerid&#39;])

            elif data[&#39;method&#39;] == &#39;Player.OnStop&#39;:
                processed = True
                self.logger.debug(&#39;received: stopped player, set playerid to 0&#39;)
                self._data_received_callback(self.device_id, &#39;state&#39;, &#39;No active player&#39;)
                self._data_received_callback(self.device_id, &#39;media&#39;, &#39;&#39;)
                self._data_received_callback(self.device_id, &#39;title&#39;, &#39;&#39;)
                self._data_received_callback(self.device_id, &#39;player&#39;, 0)
                self._data_received_callback(self.device_id, &#39;stop&#39;, True)
                self._data_received_callback(self.device_id, &#39;playpause&#39;, False)
                self._data_received_callback(self.device_id, &#39;streams&#39;, None)
                self._data_received_callback(self.device_id, &#39;subtitles&#39;, None)
                self._data_received_callback(self.device_id, &#39;audio&#39;, &#39;&#39;)
                self._data_received_callback(self.device_id, &#39;subtitle&#39;, &#39;&#39;)
                self._activeplayers = []
                self._playerid = 0

            elif data[&#39;method&#39;] == &#39;GUI.OnScreensaverActivated&#39;:
                processed = True
                self.logger.debug(&#39;received: activated screensaver&#39;)
                self._data_received_callback(self.device_id, &#39;state&#39;, &#39;Screensaver&#39;)

            elif data[&#39;method&#39;][:9] == &#39;Player.On&#39;:
                processed = True
                self.logger.debug(&#39;received: player notification&#39;)
                try:
                    p_id = data[&#39;params&#39;][&#39;data&#39;][&#39;player&#39;][&#39;playerid&#39;]
                    query_playerinfo.append(p_id)
                except KeyError:
                    pass

                try:
                    self._data_received_callback(self.device_id, &#39;media&#39;, data[&#39;params&#39;][&#39;data&#39;][&#39;item&#39;][&#39;channeltype&#39;])
                    self._data_received_callback(self.device_id, &#39;title&#39;, data[&#39;params&#39;][&#39;data&#39;][&#39;item&#39;][&#39;title&#39;])
                except KeyError:
                    pass

            elif data[&#39;method&#39;] == &#39;Application.OnVolumeChanged&#39;:
                processed = True
                self.logger.debug(&#39;received: volume changed, got new values mute: {} and volume: {}&#39;.format(data[&#39;params&#39;][&#39;data&#39;][&#39;muted&#39;], data[&#39;params&#39;][&#39;data&#39;][&#39;volume&#39;]))
                self._data_received_callback(self.device_id, &#39;mute&#39;, data[&#39;params&#39;][&#39;data&#39;][&#39;muted&#39;])
                self._data_received_callback(self.device_id, &#39;volume&#39;, data[&#39;params&#39;][&#39;data&#39;][&#39;volume&#39;])

        # if active playerid(s) was changed, update status for active player(s)
        if query_playerinfo:
            self.logger.debug(f&#39;player info query requested for playerid(s) {query_playerinfo}&#39;)
            for player_id in set(query_playerinfo):
                self.logger.debug(f&#39;getting player info for player #{player_id}&#39;)
                self._connection._send_rpc_message(&#39;Player.GetItem&#39;, {&#39;properties&#39;: [&#39;title&#39;, &#39;artist&#39;], &#39;playerid&#39;: player_id})
                self._connection._send_rpc_message(&#39;Player.GetProperties&#39;, {&#39;properties&#39;: [&#39;speed&#39;, &#39;percentage&#39;, &#39;currentaudiostream&#39;, &#39;audiostreams&#39;, &#39;subtitleenabled&#39;, &#39;currentsubtitle&#39;, &#39;subtitles&#39;], &#39;playerid&#39;: player_id})

        if processed:
            return

        # if we reach this point, no special handling case was detected, so just go on normally...

        try:
            # try and transform the JSON RPC method into the matching command
            command = self._commands.get_command_from_reply(command)
            value = self._commands.get_shng_data(command, data)
        except Exception as e:
            self.logger.info(f&#39;received data &#34;{data}&#34; for command {command}, error occurred while converting. Discarding data. Error was: {e}&#39;)
            return

        # pass on data for regular item assignment
        self.logger.debug(f&#39;received data &#34;{data}&#34; for command {command} converted to value {value}&#39;)
        self._data_received_callback(self.device_id, command, value)

    def send_command(self, command, value=None, **kwargs):
        &#39;&#39;&#39;
        Checks for special commands and handles them, otherwise call the
        base class&#39; method

        :param command: the command to send
        :param value: the data to send, if applicable
        :type command: str
        :return: True if send was successful, False otherwise
        :rtype: bool
        &#39;&#39;&#39;
        if not self.alive:
            self.logger.warning(f&#39;trying to send command {command} with value {value}, but device is not active.&#39;)
            return False

        if not self._connection:
            self.logger.warning(f&#39;trying to send command {command} with value {value}, but connection is None. This shouldn\&#39;t happen...&#39;)
            return False

        if not self._connection.connected:
            self._connection.open()
            if not self._connection.connected:
                self.logger.warning(f&#39;trying to send command {command} with value {value}, but connection could not be established.&#39;)
                return False

        if command in self._special_commands[&#39;read&#39; if value is None else &#39;write&#39;]:
            if command == &#39;update&#39;:
                if value:
                    self._update_status()
                return True
            elif value is None:
                self.logger.debug(f&#39;Special command {command} called for reading, which is not intended. Ignoring request&#39;)
                return True
            else:
                # this shouldn&#39;t happen
                self.logger.warning(f&#39;Special command {command} found, no action set for processing. Please inform developers. Ignoring request&#39;)
                return True
        else:
            return super().send_command(command, value, playerid=self._playerid, **kwargs)

    def is_valid_command(self, command, read=None):
        &#39;&#39;&#39;
        In addition to base class method, allow &#39;special&#39;
        commands not defined in commands.py which are meant
        to control the plugin device, e.g. &#39;update&#39; to read
        player status.
        If not special command, call base class method

        :param command: the command to test
        :type command: str
        :param read: check for read (True) or write (False), or both (None)
        :type read: bool | NoneType
        :return: True if command is valid, False otherwise
        :rtype: bool
        &#39;&#39;&#39;
        if command in self._special_commands[&#39;read&#39; if read else &#39;write&#39;]:
            self.logger.debug(f&#39;Acknowledging special command {command}, read is {read}&#39;)
            return True
        else:
            return super().is_valid_command(command, read)

#
# new methods
#

    def notify(self, title, message, image=None, display_time=10000):
        &#39;&#39;&#39;
        Send a notification to Kodi to be displayed on the screen

        :param title: the title of the message
        :param message: the message itself
        :param image: an optional image to be displayed alongside the message
        :param display_time: how long the message is displayed in milli seconds
        &#39;&#39;&#39;
        params = {&#39;title&#39;: title, &#39;message&#39;: message, &#39;displaytime&#39;: display_time}
        if image is not None:
            params[&#39;image&#39;] = image
        self._connection._send_rpc_message(&#39;GUI.ShowNotification&#39;, params)

    def _update_status(self):
        &#39;&#39;&#39;
        This method requests several status infos
        &#39;&#39;&#39;
        if self.alive:
            self.send_command(&#39;get_actplayer&#39;, None)
            self.send_command(&#39;get_status_au&#39;, None)
            if self._playerid:
                self.send_command(&#39;get_status_play&#39;, None)
                self.send_command(&#39;get_item&#39;, None)

    # def _check_commands_data(self):
    #     &#39;&#39;&#39;
    #     Method checks consistency of imported commands data
# 
    #     This is ported directly from the old kodi plugin; to not clutter things
    #     this method is implemented in the device class, even though it works
    #     on the commands and should have been implemented there. But overloading
    #     the commands class is not something (yet) planned...
# 
    #     :return: True if data is consistent
    #     :rtype: bool
    #     &#39;&#39;&#39;
    #     no_method = []
    #     wrong_keys = []
    #     unmatched = []
    #     bounds = []
    #     values = []
    #     for command, cmd_obj in self._commands._commands.items():
# 
    #         if not cmd_obj:
    #             print(f&#39;no obj: {cmd_obj}&#39;)
    #             
    #         # verify all keys are present
    #         if not [&#39;method&#39;, &#39;set&#39;, &#39;get&#39;, &#39;params&#39;, &#39;values&#39;, &#39;bounds&#39;].sort() == list(entry.keys()).sort():
    #             wrong_keys.append(command)
    #         elif not [&#39;set&#39;, &#39;special&#39;].sort() == list(entry.keys()).sort():
    #             # check that method is not empty
    #             if not entry[&#39;method&#39;]:
    #                 no_method.append(command)
    #             par = entry[&#39;params&#39;]
    #             val = entry[&#39;values&#39;]
    #             bnd = entry[&#39;bounds&#39;]
    #             # params and values must be either both None or both lists of equal length
    #             if par is None and val is not None or par is not None and val is None:
    #                 unmatched.append(command)
    #             elif par is not None and val is not None and len(par) != len(val):
    #                 unmatched.append(command)
    #             vals = 0
    #             if val is not None:
    #                 # check that max. one &#39;VAL&#39; entry is present
    #                 for item in val:
    #                     if item == &#39;VAL&#39;:
    #                         vals += 1
    #                 if vals &gt; 1:
    #                     values.append(command)
    #             # check that bounds are None or list or (tuple and len(bounds)=2)
    #             if bnd is not None and \
    #                not isinstance(bnd, list) and \
    #                (not (isinstance(bnd, tuple) and len(bnd) == 2)):
    #                 bounds.append(command)
    #             # check that bounds are only defined if &#39;VAL&#39; is present
    #             if vals == 0 and bnd is not None:
    #                 bounds.append(command)
# 
    #     # found any errors?
    #     if len(no_method + wrong_keys + unmatched + bounds + values) &gt; 0:
    #         if len(wrong_keys) &gt; 0:
    #             self.logger.error(&#39;Commands data not consistent: commands &#34;&#39; + &#39;&#34;, &#34;&#39;.join(wrong_keys) + &#39;&#34; have wrong keys&#39;)
    #         if len(no_method) &gt; 0:
    #             self.logger.error(&#39;Commands data not consistent: commands &#34;&#39; + &#39;&#34;, &#34;&#39;.join(no_method) + &#39;&#34; have no method&#39;)
    #         if len(unmatched) &gt; 0:
    #             self.logger.error(&#39;Commands data not consistent: commands &#34;&#39; + &#39;&#34;, &#34;&#39;.join(unmatched) + &#39;&#34; have unmatched params/values&#39;)
    #         if len(bounds) &gt; 0:
    #             self.logger.error(&#39;Commands data not consistent: commands &#34;&#39; + &#39;&#34;, &#34;&#39;.join(bounds) + &#39;&#34; have erroneous bounds&#39;)
    #         if len(values) &gt; 0:
    #             self.logger.error(&#39;Commands data not consistent: commands &#34;&#39; + &#39;&#34;, &#34;&#39;.join(values) + &#39;&#34; have more than one &#34;VAL&#34; field&#39;)
# 
    #         return False
# 
    #     macros = []
    #     for macro, entry in commands.macros.items():
    #         if not isinstance(entry, list):
    #             macros.append(macro)
    #         else:
    #             for step in entry:
    #                 if not isinstance(step, list) or len(step) != 2:
    #                     macros.append(macro)
# 
    #     if len(macros) &gt; 0:
    #         self.logger.error(&#39;Macro data not consistent for macros &#34;&#39; + &#39;&#34;, &#34;&#39;.join(macros) + &#39;&#34;&#39;)
    #         # errors in macro definition don&#39;t hinder normal plugin functionality, so just
    #         # refill self._MACRO omitting erroneous entries. With bad luck, _MACRO is empty ;)
    #         self._MACRO = {}
    #         for command, entry in command.macros:
    #             if command not in macros:
    #                 self._MACRO[command] = entry
# 
    #     return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="multidevice.MD_Device.MD_Device" href="../MD_Device.html#multidevice.MD_Device.MD_Device">MD_Device</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="multidevice.dev_kodi.device.MD_Device.is_valid_command"><code class="name flex">
<span>def <span class="ident">is_valid_command</span></span>(<span>self, command, read=None)</span>
</code></dt>
<dd>
<div class="desc"><p>In addition to base class method, allow 'special'
commands not defined in commands.py which are meant
to control the plugin device, e.g. 'update' to read
player status.
If not special command, call base class method</p>
<p>:param command: the command to test
:type command: str
:param read: check for read (True) or write (False), or both (None)
:type read: bool | NoneType
:return: True if command is valid, False otherwise
:rtype: bool</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_valid_command(self, command, read=None):
    &#39;&#39;&#39;
    In addition to base class method, allow &#39;special&#39;
    commands not defined in commands.py which are meant
    to control the plugin device, e.g. &#39;update&#39; to read
    player status.
    If not special command, call base class method

    :param command: the command to test
    :type command: str
    :param read: check for read (True) or write (False), or both (None)
    :type read: bool | NoneType
    :return: True if command is valid, False otherwise
    :rtype: bool
    &#39;&#39;&#39;
    if command in self._special_commands[&#39;read&#39; if read else &#39;write&#39;]:
        self.logger.debug(f&#39;Acknowledging special command {command}, read is {read}&#39;)
        return True
    else:
        return super().is_valid_command(command, read)</code></pre>
</details>
</dd>
<dt id="multidevice.dev_kodi.device.MD_Device.notify"><code class="name flex">
<span>def <span class="ident">notify</span></span>(<span>self, title, message, image=None, display_time=10000)</span>
</code></dt>
<dd>
<div class="desc"><p>Send a notification to Kodi to be displayed on the screen</p>
<p>:param title: the title of the message
:param message: the message itself
:param image: an optional image to be displayed alongside the message
:param display_time: how long the message is displayed in milli seconds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def notify(self, title, message, image=None, display_time=10000):
    &#39;&#39;&#39;
    Send a notification to Kodi to be displayed on the screen

    :param title: the title of the message
    :param message: the message itself
    :param image: an optional image to be displayed alongside the message
    :param display_time: how long the message is displayed in milli seconds
    &#39;&#39;&#39;
    params = {&#39;title&#39;: title, &#39;message&#39;: message, &#39;displaytime&#39;: display_time}
    if image is not None:
        params[&#39;image&#39;] = image
    self._connection._send_rpc_message(&#39;GUI.ShowNotification&#39;, params)</code></pre>
</details>
</dd>
<dt id="multidevice.dev_kodi.device.MD_Device.on_data_received"><code class="name flex">
<span>def <span class="ident">on_data_received</span></span>(<span>self, by, data, command=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback function for received data e.g. from an event loop
Processes data and dispatches value to plugin class</p>
<p>:param command: the command in reply to which data was received
:param data: received data in 'raw' connection format
:type command: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_data_received(self, by, data, command=None):
    &#39;&#39;&#39;
    Callback function for received data e.g. from an event loop
    Processes data and dispatches value to plugin class

    :param command: the command in reply to which data was received
    :param data: received data in &#39;raw&#39; connection format
    :type command: str
    &#39;&#39;&#39;
    if command is not None:
        self.logger.debug(f&#39;received data &#34;{data}&#34; for command {command}&#39;)
    else:
        self.logger.debug(f&#39;data &#34;{data}&#34; did not identify a known command&#39;)

    if not self._data_received_callback:
        self.logger.error(&#39;on_data_received callback not set, can not process device reply data, ignoring it&#39;)
        return

    if not isinstance(data, dict):
        self.logger.error(f&#39;received data {data} not in JSON (dict) format, ignoring&#39;)

    if &#39;error&#39; in data:
        # errors are handled on connection level
        return

    try:
        result_data = data.get(&#39;result&#39;)
    except Exception as e:
        self.logger.error(f&#39;Invalid response to command {command} received: {data}, ignoring. Error was: {e}&#39;)
        return
    if &#39;id&#39; in data and result_data is None:
        self.logger.info(f&#39;Empty response to command {command} received, ignoring&#39;)
        return

    query_playerinfo = []

    processed = False

    # replies to requests sent by us
    if &#39;id&#39; in data:
        if command == &#39;Player.GetActivePlayers&#39;:
            processed = True
            if len(result_data) == 1:
                # one active player
                query_playerinfo = self._activeplayers = [result_data[0].get(&#39;playerid&#39;)]
                self._playerid = self._activeplayers[0]
                self.logger.debug(f&#39;received GetActivePlayers, set playerid to {self._playerid}&#39;)
                self._data_received_callback(self.device_id, &#39;player&#39;, self._playerid)
                self._data_received_callback(self.device_id, &#39;media&#39;, result_data[0].get(&#39;type&#39;).capitalize())
            elif len(result_data) &gt; 1:
                # multiple active players. Have not yet seen this happen
                self._activeplayers = []
                for player in result_data:
                    self._activeplayers.append(player.get(&#39;playerid&#39;))
                    query_playerinfo.append(player.get(&#39;playerid&#39;))
                self._playerid = min(self._activeplayers)
                self.logger.debug(f&#39;received GetActivePlayers, set playerid to {self._playerid}&#39;)
            else:
                # no active players
                self._activeplayers = []
                self._data_received_callback(self.device_id, &#39;state&#39;, &#39;No active player&#39;)
                self._data_received_callback(self.device_id, &#39;player&#39;, 0)
                self._data_received_callback(self.device_id, &#39;title&#39;, &#39;&#39;)
                self._data_received_callback(self.device_id, &#39;media&#39;, &#39;&#39;)
                self._data_received_callback(self.device_id, &#39;stop&#39;, True)
                self._data_received_callback(self.device_id, &#39;playpause&#39;, False)
                self._data_received_callback(self.device_id, &#39;streams&#39;, None)
                self._data_received_callback(self.device_id, &#39;subtitles&#39;, None)
                self._data_received_callback(self.device_id, &#39;audio&#39;, &#39;&#39;)
                self._data_received_callback(self.device_id, &#39;subtitle&#39;, &#39;&#39;)
                self._playerid = 0
                self.logger.debug(&#39;received GetActivePlayers, reset playerid to 0&#39;)

        # got status info
        elif command == &#39;Application.GetProperties&#39;:
            processed = True
            muted = result_data.get(&#39;muted&#39;)
            volume = result_data.get(&#39;volume&#39;)
            self.logger.debug(f&#39;received GetProperties: change mute to {muted} and volume to {volume}&#39;)
            self._data_received_callback(self.device_id, &#39;mute&#39;, muted)
            self._data_received_callback(self.device_id, &#39;volume&#39;, volume)

        # got favourites
        elif command == &#39;Favourites.GetFavourites&#39;:
            processed = True
            if not result_data.get(&#39;favourites&#39;):
                self.logger.debug(&#39;No favourites found.&#39;)
            else:
                item_dict = {item[&#39;title&#39;]: item for item in result_data.get(&#39;favourites&#39;)}
                self.logger.debug(f&#39;favourites found: {item_dict}&#39;)
                self._data_received_callback(self.device_id, &#39;get_favourites&#39;, item_dict)

        # got item info
        elif command == &#39;Player.GetItem&#39;:
            processed = True
            title = result_data[&#39;item&#39;].get(&#39;title&#39;)
            player_type = result_data[&#39;item&#39;].get(&#39;type&#39;)
            if not title:
                title = result_data[&#39;item&#39;].get(&#39;label&#39;)
            self._data_received_callback(self.device_id, &#39;media&#39;, player_type.capitalize())
            if player_type == &#39;audio&#39; and &#39;artist&#39; in result_data[&#39;item&#39;]:
                artist = &#39;unknown&#39; if len(result_data[&#39;item&#39;].get(&#39;artist&#39;)) == 0 else result_data[&#39;item&#39;].get(&#39;artist&#39;)[0]
                title = artist + &#39; - &#39; + title
            if title:
                self._data_received_callback(self.device_id, &#39;title&#39;, title)
            self.logger.debug(f&#39;received GetItem: update player info to title={title}, type={player_type}&#39;)

        # got player status
        elif command == &#39;Player.GetProperties&#39;:
            processed = True
            self.logger.debug(&#39;Received Player.GetProperties, update media data&#39;)
            self._data_received_callback(self.device_id, &#39;speed&#39;, result_data.get(&#39;speed&#39;))
            self._data_received_callback(self.device_id, &#39;seek&#39;, result_data.get(&#39;percentage&#39;))
            self._data_received_callback(self.device_id, &#39;streams&#39;, result_data.get(&#39;audiostreams&#39;))
            self._data_received_callback(self.device_id, &#39;audio&#39;, result_data.get(&#39;currentaudiostream&#39;))
            self._data_received_callback(self.device_id, &#39;subtitles&#39;, result_data.get(&#39;subtitles&#39;))
            if result_data.get(&#39;subtitleenabled&#39;):
                subtitle = result_data.get(&#39;currentsubtitle&#39;)
            else:
                subtitle = &#39;Off&#39;
            self._data_received_callback(self.device_id, &#39;subtitle&#39;, subtitle)

            # speed != 0 -&gt; play; speed == 0 -&gt; pause
            if result_data.get(&#39;speed&#39;) == 0:
                self._data_received_callback(self.device_id, &#39;state&#39;, &#39;Paused&#39;)
                self._data_received_callback(self.device_id, &#39;stop&#39;, False)
                self._data_received_callback(self.device_id, &#39;playpause&#39;, False)
            else:
                self._data_received_callback(self.device_id, &#39;state&#39;, &#39;Playing&#39;)
                self._data_received_callback(self.device_id, &#39;stop&#39;, False)
                self._data_received_callback(self.device_id, &#39;playpause&#39;, True)

    # not replies, but event notifications.
    elif &#39;method&#39; in data:

        # no id, notification or other
        if data[&#39;method&#39;] == &#39;Player.OnResume&#39;:
            processed = True
            self.logger.debug(&#39;received: resumed player&#39;)
            self._data_received_callback(self.device_id, &#39;state&#39;, &#39;Playing&#39;)
            self._data_received_callback(self.device_id, &#39;stop&#39;, False)
            self._data_received_callback(self.device_id, &#39;playpause&#39;, True)
            query_playerinfo.append(data[&#39;params&#39;][&#39;data&#39;][&#39;player&#39;][&#39;playerid&#39;])

        elif data[&#39;method&#39;] == &#39;Player.OnPause&#39;:
            processed = True
            self.logger.debug(&#39;received: paused player&#39;)
            self._data_received_callback(self.device_id, &#39;state&#39;, &#39;Paused&#39;)
            self._data_received_callback(self.device_id, &#39;stop&#39;, False)
            self._data_received_callback(self.device_id, &#39;playpause&#39;, False)
            query_playerinfo.append(data[&#39;params&#39;][&#39;data&#39;][&#39;player&#39;][&#39;playerid&#39;])

        elif data[&#39;method&#39;] == &#39;Player.OnStop&#39;:
            processed = True
            self.logger.debug(&#39;received: stopped player, set playerid to 0&#39;)
            self._data_received_callback(self.device_id, &#39;state&#39;, &#39;No active player&#39;)
            self._data_received_callback(self.device_id, &#39;media&#39;, &#39;&#39;)
            self._data_received_callback(self.device_id, &#39;title&#39;, &#39;&#39;)
            self._data_received_callback(self.device_id, &#39;player&#39;, 0)
            self._data_received_callback(self.device_id, &#39;stop&#39;, True)
            self._data_received_callback(self.device_id, &#39;playpause&#39;, False)
            self._data_received_callback(self.device_id, &#39;streams&#39;, None)
            self._data_received_callback(self.device_id, &#39;subtitles&#39;, None)
            self._data_received_callback(self.device_id, &#39;audio&#39;, &#39;&#39;)
            self._data_received_callback(self.device_id, &#39;subtitle&#39;, &#39;&#39;)
            self._activeplayers = []
            self._playerid = 0

        elif data[&#39;method&#39;] == &#39;GUI.OnScreensaverActivated&#39;:
            processed = True
            self.logger.debug(&#39;received: activated screensaver&#39;)
            self._data_received_callback(self.device_id, &#39;state&#39;, &#39;Screensaver&#39;)

        elif data[&#39;method&#39;][:9] == &#39;Player.On&#39;:
            processed = True
            self.logger.debug(&#39;received: player notification&#39;)
            try:
                p_id = data[&#39;params&#39;][&#39;data&#39;][&#39;player&#39;][&#39;playerid&#39;]
                query_playerinfo.append(p_id)
            except KeyError:
                pass

            try:
                self._data_received_callback(self.device_id, &#39;media&#39;, data[&#39;params&#39;][&#39;data&#39;][&#39;item&#39;][&#39;channeltype&#39;])
                self._data_received_callback(self.device_id, &#39;title&#39;, data[&#39;params&#39;][&#39;data&#39;][&#39;item&#39;][&#39;title&#39;])
            except KeyError:
                pass

        elif data[&#39;method&#39;] == &#39;Application.OnVolumeChanged&#39;:
            processed = True
            self.logger.debug(&#39;received: volume changed, got new values mute: {} and volume: {}&#39;.format(data[&#39;params&#39;][&#39;data&#39;][&#39;muted&#39;], data[&#39;params&#39;][&#39;data&#39;][&#39;volume&#39;]))
            self._data_received_callback(self.device_id, &#39;mute&#39;, data[&#39;params&#39;][&#39;data&#39;][&#39;muted&#39;])
            self._data_received_callback(self.device_id, &#39;volume&#39;, data[&#39;params&#39;][&#39;data&#39;][&#39;volume&#39;])

    # if active playerid(s) was changed, update status for active player(s)
    if query_playerinfo:
        self.logger.debug(f&#39;player info query requested for playerid(s) {query_playerinfo}&#39;)
        for player_id in set(query_playerinfo):
            self.logger.debug(f&#39;getting player info for player #{player_id}&#39;)
            self._connection._send_rpc_message(&#39;Player.GetItem&#39;, {&#39;properties&#39;: [&#39;title&#39;, &#39;artist&#39;], &#39;playerid&#39;: player_id})
            self._connection._send_rpc_message(&#39;Player.GetProperties&#39;, {&#39;properties&#39;: [&#39;speed&#39;, &#39;percentage&#39;, &#39;currentaudiostream&#39;, &#39;audiostreams&#39;, &#39;subtitleenabled&#39;, &#39;currentsubtitle&#39;, &#39;subtitles&#39;], &#39;playerid&#39;: player_id})

    if processed:
        return

    # if we reach this point, no special handling case was detected, so just go on normally...

    try:
        # try and transform the JSON RPC method into the matching command
        command = self._commands.get_command_from_reply(command)
        value = self._commands.get_shng_data(command, data)
    except Exception as e:
        self.logger.info(f&#39;received data &#34;{data}&#34; for command {command}, error occurred while converting. Discarding data. Error was: {e}&#39;)
        return

    # pass on data for regular item assignment
    self.logger.debug(f&#39;received data &#34;{data}&#34; for command {command} converted to value {value}&#39;)
    self._data_received_callback(self.device_id, command, value)</code></pre>
</details>
</dd>
<dt id="multidevice.dev_kodi.device.MD_Device.send_command"><code class="name flex">
<span>def <span class="ident">send_command</span></span>(<span>self, command, value=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks for special commands and handles them, otherwise call the
base class' method</p>
<p>:param command: the command to send
:param value: the data to send, if applicable
:type command: str
:return: True if send was successful, False otherwise
:rtype: bool</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_command(self, command, value=None, **kwargs):
    &#39;&#39;&#39;
    Checks for special commands and handles them, otherwise call the
    base class&#39; method

    :param command: the command to send
    :param value: the data to send, if applicable
    :type command: str
    :return: True if send was successful, False otherwise
    :rtype: bool
    &#39;&#39;&#39;
    if not self.alive:
        self.logger.warning(f&#39;trying to send command {command} with value {value}, but device is not active.&#39;)
        return False

    if not self._connection:
        self.logger.warning(f&#39;trying to send command {command} with value {value}, but connection is None. This shouldn\&#39;t happen...&#39;)
        return False

    if not self._connection.connected:
        self._connection.open()
        if not self._connection.connected:
            self.logger.warning(f&#39;trying to send command {command} with value {value}, but connection could not be established.&#39;)
            return False

    if command in self._special_commands[&#39;read&#39; if value is None else &#39;write&#39;]:
        if command == &#39;update&#39;:
            if value:
                self._update_status()
            return True
        elif value is None:
            self.logger.debug(f&#39;Special command {command} called for reading, which is not intended. Ignoring request&#39;)
            return True
        else:
            # this shouldn&#39;t happen
            self.logger.warning(f&#39;Special command {command} found, no action set for processing. Please inform developers. Ignoring request&#39;)
            return True
    else:
        return super().send_command(command, value, playerid=self._playerid, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="multidevice.MD_Device.MD_Device" href="../MD_Device.html#multidevice.MD_Device.MD_Device">MD_Device</a></b></code>:
<ul class="hlist">
<li><code><a title="multidevice.MD_Device.MD_Device.get_lookup" href="../MD_Device.html#multidevice.MD_Device.MD_Device.get_lookup">get_lookup</a></code></li>
<li><code><a title="multidevice.MD_Device.MD_Device.on_connect" href="../MD_Device.html#multidevice.MD_Device.MD_Device.on_connect">on_connect</a></code></li>
<li><code><a title="multidevice.MD_Device.MD_Device.on_disconnect" href="../MD_Device.html#multidevice.MD_Device.MD_Device.on_disconnect">on_disconnect</a></code></li>
<li><code><a title="multidevice.MD_Device.MD_Device.read_all_commands" href="../MD_Device.html#multidevice.MD_Device.MD_Device.read_all_commands">read_all_commands</a></code></li>
<li><code><a title="multidevice.MD_Device.MD_Device.set_runtime_data" href="../MD_Device.html#multidevice.MD_Device.MD_Device.set_runtime_data">set_runtime_data</a></code></li>
<li><code><a title="multidevice.MD_Device.MD_Device.update_device_params" href="../MD_Device.html#multidevice.MD_Device.MD_Device.update_device_params">update_device_params</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="multidevice.dev_kodi" href="index.html">multidevice.dev_kodi</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="multidevice.dev_kodi.device.MD_Device" href="#multidevice.dev_kodi.device.MD_Device">MD_Device</a></code></h4>
<ul class="">
<li><code><a title="multidevice.dev_kodi.device.MD_Device.is_valid_command" href="#multidevice.dev_kodi.device.MD_Device.is_valid_command">is_valid_command</a></code></li>
<li><code><a title="multidevice.dev_kodi.device.MD_Device.notify" href="#multidevice.dev_kodi.device.MD_Device.notify">notify</a></code></li>
<li><code><a title="multidevice.dev_kodi.device.MD_Device.on_data_received" href="#multidevice.dev_kodi.device.MD_Device.on_data_received">on_data_received</a></code></li>
<li><code><a title="multidevice.dev_kodi.device.MD_Device.send_command" href="#multidevice.dev_kodi.device.MD_Device.send_command">send_command</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>