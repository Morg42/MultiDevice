<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>multidevice.MD_Command API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>multidevice.MD_Command</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# vim: set encoding=utf-8 tabstop=4 softtabstop=4 shiftwidth=4 expandtab
#########################################################################
#  Copyright 2020-      Sebastian Helms             Morg @ knx-user-forum
#########################################################################
#  This file aims to become part of SmartHomeNG.
#  https://www.smarthomeNG.de
#  https://knx-user-forum.de/forum/supportforen/smarthome-py
#
#  MD_Command and derived classes for MultiDevice plugin
#
#  SmartHomeNG is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  SmartHomeNG is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with SmartHomeNG. If not, see &lt;http://www.gnu.org/licenses/&gt;.
#
#########################################################################

import logging
import re

if MD_standalone:
    from MD_Globals import *
    import datatypes as DT
else:
    from .MD_Globals import *
    from . import datatypes as DT


#############################################################################################################################################################################################################################################
#
# class MD_Command
#
#############################################################################################################################################################################################################################################

class MD_Command(object):
    &#34;&#34;&#34; MD_Command class for command data handling

    This class represents a general command that uses read_cmd/write_cmd or, if
    not present, opcode as payload for the connection. Data is supplied in the
    &#39;data&#39;-key values in the data_dict. DT type conversion is applied with default
    values.

    For attributes defined in commands.py, see explanation in the
    dev_example/commands.py file.

    This class serves as a base class for further format-specific command types.
    &#34;&#34;&#34;
    device_id = &#39;&#39;
    name = &#39;&#39;
    opcode = &#39;&#39;
    read = False
    write = False
    read_cmd = None
    write_cmd = None
    item_type = None
    reply_token = []
    reply_pattern = &#39;&#39;
    settings = None
    lookup = None
    _DT = None

    def __init__(self, device_id, command, dt_class, **kwargs):

        # get MultiDevice.device logger (if not already defined by derived class calling us via super().__init__())
        if not hasattr(self, &#39;logger&#39;):
            self.logger = logging.getLogger(&#39;.&#39;.join(__name__.split(&#39;.&#39;)[:-1]) + f&#39;.{device_id}&#39;)

        if not device_id:
            self.logger.warning(f&#39;building command {command} without a device, aborting&#39;)
        else:
            self.device_id = device_id

        if not command:
            self.logger.warning(f&#39;building command without a name, aborting&#39;)
            return
        else:
            self.name = command

        kw = kwargs[&#39;cmd&#39;]
        self._plugin_params = kwargs[&#39;plugin&#39;]

        self._get_kwargs(COMMAND_PARAMS, **kw)

        try:
            self._DT = dt_class()
        except Exception as e:
            self.logger.error(f&#39;building command {command} failed on instantiating datatype class {dt_class}. Error was: {e}&#39;)
            self._DT = DT.DT_raw()

        # only log if base class. Derived classes log their own messages
        if self.__class__ is MD_Command:
            self.logger.debug(f&#39;learned command {command} with device datatype {dt_class}&#39;)

    def get_send_data(self, data, **kwargs):

        cmd = None

        data = self._check_value(data)

        # create read data
        if data is None:
            if self.read_cmd:
                cmd = self.read_cmd
            else:
                cmd = self.opcode
        else:
            if self.write_cmd:
                cmd = self.write_cmd
            else:
                cmd = self.opcode

        return {&#39;payload&#39;: cmd, &#39;data&#39;: self._DT.get_send_data(data)}

    def get_shng_data(self, data, **kwargs):
        value = self._DT.get_shng_data(data, **kwargs)
        return value

    def get_lookup(self):
        &#34;&#34;&#34; getter for lookup &#34;&#34;&#34;
        return self.lookup

    def _get_kwargs(self, args, **kwargs):
        &#34;&#34;&#34;
        check if any items from args is present in kwargs and set the class property
        of the same name to its value.

        :param args: list or tuple of parameter names
        :type args: list | tuple
        &#34;&#34;&#34;
        for arg in args:
            if kwargs.get(arg, None):
                setattr(self, arg, kwargs[arg])

    def _check_min_max(self, data, key, min=True, force=False):
        &#34;&#34;&#34; helper routine to check for min/max compliance and int/float type &#34;&#34;&#34;
        if key in self.settings:
            bound = self.settings[key]
            if not isinstance(data, type(bound)):
                if type(data) is float and type(bound) is int:
                    data = int(data)
                elif type(data) is int and type(bound) is float:
                    data = float(data)
                else:
                    raise ValueError(f&#39;type {type(data)} ({data}) given for {type(bound)} ({bound})&#39;)
            if (min and data &gt;= bound) or (not min and data &lt;= bound):
                return data
            if force:
                self.logger.debug(f&#39;Value {data} changed to {bound} due to settings {self.settings}&#39;)
                return bound
            raise ValueError(f&#39;value {data} not adhering to {&#34;min&#34; if min else &#34;max&#34;} value {bound}&#39;)
        return data

    def _check_value(self, data):
        &#34;&#34;&#34;
        check if value settings are defined and if so, if they are followed
        possibly adjust data in accordance with settings

        non-compliance will raise ValueError

        This can be overwritten; make sure to call
        data = super()._check_value(data)
        to run this code in addition to your own extension, if applicable.
        Take care of the sequence of changing data, though...

        :param data: data/value to send
        :return: adjusted data
        &#34;&#34;&#34;
        if data is not None:
            try:
                if self.settings and not self.lookup:
                    if self.settings.get(&#39;valid_list_ci&#39;, None):
                        val = data
                        if isinstance(data, str):
                            val = data.lower()
                        if val not in self.settings[&#39;valid_list_ci&#39;]:
                            raise ValueError(f&#39;value {val} not in case insensitive list {self.settings[&#34;valid_list_ci&#34;]}&#39;)
                    elif self.settings.get(&#39;valid_list&#39;, None):
                        if data not in self.settings[&#39;valid_list&#39;]:
                            raise ValueError(f&#39;value {data} not in list {self.settings[&#34;valid_list&#34;]}&#39;)
                    # min/max not in addition to valid_list
                    elif any(key in self.settings.keys() for key in MINMAXKEYS):
                        for key in MINMAXKEYS:
                            data = self._check_min_max(data, key, key[-3:] == &#39;min&#39;, key[:5] == &#39;force&#39;)

            except Exception as e:
                raise ValueError(f&#39;Given invalid value for command {self.name} due to settings. Error was: {e}&#39;)

        return data


class MD_Command_Str(MD_Command):
    &#34;&#34;&#34; Command for string-based communication

    This class represents a command which uses a string with arguments as payload,
    for example as query URL.

    Default behaviour is identical to MD_Command_Str.

    For sending, the read_cmd/write_cmd strings, opcode and data are parsed
    (recursively), to enable the following parameters:

    - &#39;MD_OPCODE&#39; is replaced with the opcode,
    - &#39;MD_PARAM:attr:&#39; is replaced with the value of the attr element from the plugin configuration,
    - &#39;MD_VALUE&#39; is replaced with the given value (converted by DT-class)

    The returned data is only parsed by the DT_... classes.
    For the DT_json class, the read_data dict can be used to extract a specific
    element from a json response:

    ``read_data = {&#39;dict&#39;: [&#39;key1&#39;, &#39;key2&#39;, &#39;key3&#39;]}``

    would try to get

    ``json_response[&#39;key1&#39;][&#39;key2&#39;][&#39;key3&#39;]``

    and return it as the read value.

    This class is provided as a reference implementation for the Net-Connections.
    &#34;&#34;&#34;
    read_data = None

    def get_send_data(self, data, **kwargs):

        data = self._check_value(data)

        if data is None:
            # create read data
            if self.read_cmd:
                cmd_str = self._parse_str(self.read_cmd)
            else:
                cmd_str = self._parse_str(self.opcode, data)
        else:
            # create write data
            if self.write_cmd:
                cmd_str = self._parse_str(self.write_cmd, data)
            else:
                cmd_str = self._parse_str(self.opcode, data)

        data_dict = {}
        data_dict[&#39;payload&#39;] = cmd_str
        for k in self._plugin_params.keys():
            data_dict[k] = self._parse_tree(self.params[k], data)

        return data_dict

    def get_shng_data(self, data, **kwargs):
        if isinstance(data, (bytes, bytearray)):
            data = data.decode(&#39;utf-8&#39;)
        value = self._DT.get_shng_data(data, **kwargs)
        return value

    def _parse_str(self, string, data=None):
        &#34;&#34;&#34;
        parse string and replace
        - MD_OPCODE with the command opcode
        - MD_PARAM:&lt;elem&gt;: with the plugin parameter
        - MD_VALUE with the data value

        The replacement order ensures that MD_PARAM-patterns from the opcode
        can be replaced as well as MD_VALUE-pattern in any of the strings.
        &#34;&#34;&#34;
        def repl_func(matchobj):
            return str(self._plugin_params.get(matchobj.group(2), &#39;&#39;))

        string = string.replace(&#39;MD_OPCODE&#39;, self.opcode)

        regex = &#39;(MD_PARAM:([^:]+):)&#39;
        while re.match(&#39;.*&#39; + regex + &#39;.*&#39;, string):
            string = re.sub(regex, repl_func, string)

        if data is not None:
            string = string.replace(&#39;MD_VALUE&#39;, str(self._DT.get_send_data(data)))

        return string

    def _parse_tree(self, node, data):
        &#34;&#34;&#34;
        traverse node and
        - apply _parse_str to strings
        - recursively _parse_tree for all elements of iterables or
        - return unknown or unparseable elements unchanged
        &#34;&#34;&#34;
        if issubclass(node, str):
            return self._parse_str(node, data)
        elif issubclass(node, list):
            return [self._parse_tree(k, data) for k in node]
        elif issubclass(node, tuple):
            return (self._parse_tree(k, data) for k in node)
        elif issubclass(node, dict):
            new_dict = {}
            for k in node.keys():
                new_dict[k] = self._parse_tree(node[k], data)
            return new_dict
        else:
            return node


class MD_Command_ParseStr(MD_Command_Str):
    &#34;&#34;&#34; Command for string-based communication with parsed arguments

    With this class, you can simplify the creation of read and write commands
    containing data values.

    Default behaviour is identical to MD_Command_Str.

    Giving write_cmd as &#39;:&lt;write expression&gt;:&#39; (note colons) will format the
    given string (without the colons), replacing &#39;VAL&#39; with the value by using
    write_cmd.format(VAL=data_dict[&#39;payload&#39;]), so you can immediately embed
    the value in the command string with configurable formatting conforming
    to str.format() syntax.
    If you have to start and end the command string with colons, just use
    &#39;::foo::&#39; as write_cmd. If you absolutely HAVE to use a literal
    &#39;:foo{VAL}bar:&#39;, you might need to write your own class...

    Giving reply_pattern as &#39;&lt;regex&gt;&#39; with one (1) match group will try and
    capture the matched group into the received value.

    Giving reply_pattern as &#39;&lt;regex&gt;&#39; without capturing parentheses will return
    the reply value as is (can possibly be converted by the DT class).

    HINT: If you give reply_pattern as regex and reply_token as &#39;REGEX&#39;, the
    reply_pattern regex will be used to identify a reply as belonging to this
    command if a match is found.

    Both results can be achieved with customized DT_foo classes, but this
    might be an easier and cleaner solution. Please make sure to understand
    MRE by JF properly :)
    &#34;&#34;&#34;

    def get_send_data(self, data, **kwargs):

        data = self._check_value(data)

        if data is None:
            # create read data
            if self.read_cmd:
                cmd_str = self._parse_str(self.read_cmd)
            else:
                cmd_str = self._parse_str(self.opcode, data)
        else:
            # create write data
            if self.write_cmd:
                # test if write_cmd is &#39;:foo:&#39; to trigger formatting/substitution
                # reminder: &#39;:val:&#39; replaces val with &#39;raw&#39; val, &#39;MD_VALUE&#39; uses DT.get_send_data(val)
                if self.write_cmd[0] == &#39;:&#39; and self.write_cmd[-1] == &#39;:&#39;:
                    if isinstance(data, str):
                        cmd_str = self._parse_str(self.write_cmd[1:-1].format(VAL=data, VAL_UPPER=data.upper(), VAL_LOWER=data.lower(), VAL_CAP=data.capitalize()), data)
                    else:
                        cmd_str = self._parse_str(self.write_cmd[1:-1].format(VAL=data))
                else:
                    cmd_str = self._parse_str(self.write_cmd, data)
            else:
                cmd_str = self._parse_str(self.opcode, data)

        return {&#39;payload&#39;: cmd_str, &#39;data&#39;: None if data is None else self._DT.get_send_data(data)}

    def get_shng_data(self, data, **kwargs):
        &#34;&#34;&#34;
        Try to match data to reply_pattern if reply_pattern is set.

        If a match is found and a value is captured, it will be returned.

        If a match is found without a capturing group, the value will be
        returned as-is, possibly to be converted by the DT class.

        If no match can be achieved, it is not possible to return
        a meaningful value. To signal the error, an exception will be raised.
        &#34;&#34;&#34;
        if isinstance(data, (bytes, bytearray)):
            data = data.decode(&#39;utf-8&#39;)

        self.logger.debug(f&#39;parse_str command got data {data} of type {type(data)}&#39;)

        if self.reply_pattern:
            regex = re.compile(self.reply_pattern)
            match = regex.match(data)
            if match:
                if len(match.groups()) == 1:

                    # one captured group - ok
                    value = self._DT.get_shng_data(match.group(1), **kwargs)
                elif len(match.groups()) &gt; 1:

                    # more than one captured group - error
                    raise ValueError(f&#39;reply_pattern {self.reply_pattern} has more than one pair of capturing parentheses&#39;)
                else:

                    # no captured groups = no parentheses = no extraction of value, just do the &#34;normal&#34; thing
                    value = self._DT.get_shng_data(data, **kwargs)
            else:
                raise ValueError(f&#39;reply_pattern {self.reply_pattern} could not get a match on {data}&#39;)
        else:
            value = self._DT.get_shng_data(data, **kwargs)
        return value


class MD_Command_JSON(MD_Command):
    &#34;&#34;&#34; Command for JSON-RPC communication

    With this class, you can send JSON-RPC commands to the device and read
    from it.

    The command is sent as &#39;method&#39;, the params-dict is populated from the
    CMD_ATTR_PARAMS attribute of the command, while the parameter values are
    taken from the CMD_ATTR_PARAM_VALUES attribute. &#39;VAL&#39; is replaced with the
    actual item value.

    params and param_value need to be None or lists of the same length.
    &#34;&#34;&#34;

    def get_send_data(self, data, **kwargs):

        cmd = None
        data = self._check_value(data)
        # create read data
        if data is None:
            if self.read_cmd:
                cmd = self.read_cmd
            else:
                cmd = self.opcode
        else:
            if self.write_cmd:
                cmd = self.write_cmd
            else:
                cmd = self.opcode
        ddict = self._build_dict(self._DT.get_send_data(data), **kwargs)
        return {&#39;payload&#39;: cmd, &#39;data&#39;: ddict}

    def get_shng_data(self, data, **kwargs):
        value = self._DT.get_shng_data(data.get(&#39;result&#39;), **kwargs)
        return value

    def _build_dict(self, data, **kwargs):
        &#34;&#34;&#34;
        build param array for JSON RPC from provided value and kwargs

        :param data: value for the command
        :param kwargs: additional data
        :return: params-dict (or None)
        :rtype: dict
        &#34;&#34;&#34;
        params = {}
        if not hasattr(self, CMD_ATTR_PARAMS):
            return None

        if not hasattr(self, CMD_ATTR_PARAM_VALUES):
            raise SyntaxError(f&#39;params {kwargs[&#34;params&#34;]} given, but no param_values&#39;)

        if len(self.params) != len(self.param_values):
            raise SyntaxError(f&#39;different number of params and values given ({self.params}/{self.param_values})&#39;)

        for idx in range(len(self.params)):
            val = self.param_values[idx]
            if val == &#39;VAL&#39;:
                val = data
            elif isinstance(val, tuple):
                try:
                    expr = str(val[0]).replace(&#39;VAL&#39;, str(data))
                    val = eval(expr)
                except Exception as e:
                    raise ValueError(f&#39;invalid data: eval expression {val} with argument {data} raised error: {e}&#39;)

            params[self.params[idx]] = val

        if &#39;playerid&#39; in params and &#39;playerid&#39; in kwargs:
            params[&#39;playerid&#39;] = kwargs[&#39;playerid&#39;]

        return params


class MD_Command_Viessmann(MD_Command):
    &#34;&#34;&#34; Command for Viessmann binary command format

    With this class, you can send commands to Viessmann heating systems

    The command is sent as &#39;method&#39;, the params-dict is populated from the
    CMD_ATTR_PARAMS attribute of the command, while the parameter values are
    taken from the CMD_ATTR_PARAM_VALUES attribute. &#39;VAL&#39; is replaced with the
    actual item value.

    params and param_value need to be None or lists of the same length.
    &#34;&#34;&#34;
    def __init__(self, device_id, command, dt_class, **kwargs):
        super().__init__(device_id, command, dt_class, **kwargs)

        self._len = 1
        self._mult = 0
        self._signed = False
        for attr in (&#39;len&#39;, &#39;mult&#39;, &#39;signed&#39;):
            if attr in self.params:
                setattr(self, &#39;_&#39; + attr, self.param_values[self.params.index(attr)])

    def get_send_data(self, data, **kwargs):

        data = self._check_value(data)
        # create read data
        if data is None:
            if self.read_cmd:
                cmd = self.read_cmd
            else:
                cmd = self.opcode
        else:
            if self.write_cmd:
                cmd = self.write_cmd
            else:
                cmd = self.opcode

        ddict = self._build_dict(self._DT.get_send_data(data, len=self._len, mult=self._mult, signed=self._signed), **kwargs)
        return {&#39;payload&#39;: cmd, &#39;data&#39;: ddict}

    def _build_dict(self, data, **kwargs):
        &#34;&#34;&#34;
        build param array for JSON RPC from provided value and kwargs

        :param data: value for the command
        :param kwargs: additional data
        :return: params-dict (or None)
        :rtype: dict
        &#34;&#34;&#34;
        params = {}
        if not hasattr(self, CMD_ATTR_PARAMS):
            return None

        if not hasattr(self, CMD_ATTR_PARAM_VALUES):
            raise SyntaxError(f&#39;params {kwargs[&#34;params&#34;]} given, but no param_values&#39;)

        if len(self.params) != len(self.param_values):
            raise SyntaxError(f&#39;different number of params and values given ({self.params}/{self.param_values})&#39;)

        for idx in range(len(self.params)):
            val = self.param_values[idx]
            if val == &#39;VAL&#39;:
                val = data
            elif isinstance(val, tuple):
                try:
                    expr = str(val[0]).replace(&#39;VAL&#39;, str(data))
                    val = eval(expr)
                except Exception as e:
                    raise ValueError(f&#39;invalid data: eval expression {val} with argument {data} raised error: {e}&#39;)

            params[self.params[idx]] = val

        return params</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="multidevice.MD_Command.MD_Command"><code class="flex name class">
<span>class <span class="ident">MD_Command</span></span>
<span>(</span><span>device_id, command, dt_class, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MD_Command class for command data handling</p>
<p>This class represents a general command that uses read_cmd/write_cmd or, if
not present, opcode as payload for the connection. Data is supplied in the
'data'-key values in the data_dict. DT type conversion is applied with default
values.</p>
<p>For attributes defined in commands.py, see explanation in the
dev_example/commands.py file.</p>
<p>This class serves as a base class for further format-specific command types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MD_Command(object):
    &#34;&#34;&#34; MD_Command class for command data handling

    This class represents a general command that uses read_cmd/write_cmd or, if
    not present, opcode as payload for the connection. Data is supplied in the
    &#39;data&#39;-key values in the data_dict. DT type conversion is applied with default
    values.

    For attributes defined in commands.py, see explanation in the
    dev_example/commands.py file.

    This class serves as a base class for further format-specific command types.
    &#34;&#34;&#34;
    device_id = &#39;&#39;
    name = &#39;&#39;
    opcode = &#39;&#39;
    read = False
    write = False
    read_cmd = None
    write_cmd = None
    item_type = None
    reply_token = []
    reply_pattern = &#39;&#39;
    settings = None
    lookup = None
    _DT = None

    def __init__(self, device_id, command, dt_class, **kwargs):

        # get MultiDevice.device logger (if not already defined by derived class calling us via super().__init__())
        if not hasattr(self, &#39;logger&#39;):
            self.logger = logging.getLogger(&#39;.&#39;.join(__name__.split(&#39;.&#39;)[:-1]) + f&#39;.{device_id}&#39;)

        if not device_id:
            self.logger.warning(f&#39;building command {command} without a device, aborting&#39;)
        else:
            self.device_id = device_id

        if not command:
            self.logger.warning(f&#39;building command without a name, aborting&#39;)
            return
        else:
            self.name = command

        kw = kwargs[&#39;cmd&#39;]
        self._plugin_params = kwargs[&#39;plugin&#39;]

        self._get_kwargs(COMMAND_PARAMS, **kw)

        try:
            self._DT = dt_class()
        except Exception as e:
            self.logger.error(f&#39;building command {command} failed on instantiating datatype class {dt_class}. Error was: {e}&#39;)
            self._DT = DT.DT_raw()

        # only log if base class. Derived classes log their own messages
        if self.__class__ is MD_Command:
            self.logger.debug(f&#39;learned command {command} with device datatype {dt_class}&#39;)

    def get_send_data(self, data, **kwargs):

        cmd = None

        data = self._check_value(data)

        # create read data
        if data is None:
            if self.read_cmd:
                cmd = self.read_cmd
            else:
                cmd = self.opcode
        else:
            if self.write_cmd:
                cmd = self.write_cmd
            else:
                cmd = self.opcode

        return {&#39;payload&#39;: cmd, &#39;data&#39;: self._DT.get_send_data(data)}

    def get_shng_data(self, data, **kwargs):
        value = self._DT.get_shng_data(data, **kwargs)
        return value

    def get_lookup(self):
        &#34;&#34;&#34; getter for lookup &#34;&#34;&#34;
        return self.lookup

    def _get_kwargs(self, args, **kwargs):
        &#34;&#34;&#34;
        check if any items from args is present in kwargs and set the class property
        of the same name to its value.

        :param args: list or tuple of parameter names
        :type args: list | tuple
        &#34;&#34;&#34;
        for arg in args:
            if kwargs.get(arg, None):
                setattr(self, arg, kwargs[arg])

    def _check_min_max(self, data, key, min=True, force=False):
        &#34;&#34;&#34; helper routine to check for min/max compliance and int/float type &#34;&#34;&#34;
        if key in self.settings:
            bound = self.settings[key]
            if not isinstance(data, type(bound)):
                if type(data) is float and type(bound) is int:
                    data = int(data)
                elif type(data) is int and type(bound) is float:
                    data = float(data)
                else:
                    raise ValueError(f&#39;type {type(data)} ({data}) given for {type(bound)} ({bound})&#39;)
            if (min and data &gt;= bound) or (not min and data &lt;= bound):
                return data
            if force:
                self.logger.debug(f&#39;Value {data} changed to {bound} due to settings {self.settings}&#39;)
                return bound
            raise ValueError(f&#39;value {data} not adhering to {&#34;min&#34; if min else &#34;max&#34;} value {bound}&#39;)
        return data

    def _check_value(self, data):
        &#34;&#34;&#34;
        check if value settings are defined and if so, if they are followed
        possibly adjust data in accordance with settings

        non-compliance will raise ValueError

        This can be overwritten; make sure to call
        data = super()._check_value(data)
        to run this code in addition to your own extension, if applicable.
        Take care of the sequence of changing data, though...

        :param data: data/value to send
        :return: adjusted data
        &#34;&#34;&#34;
        if data is not None:
            try:
                if self.settings and not self.lookup:
                    if self.settings.get(&#39;valid_list_ci&#39;, None):
                        val = data
                        if isinstance(data, str):
                            val = data.lower()
                        if val not in self.settings[&#39;valid_list_ci&#39;]:
                            raise ValueError(f&#39;value {val} not in case insensitive list {self.settings[&#34;valid_list_ci&#34;]}&#39;)
                    elif self.settings.get(&#39;valid_list&#39;, None):
                        if data not in self.settings[&#39;valid_list&#39;]:
                            raise ValueError(f&#39;value {data} not in list {self.settings[&#34;valid_list&#34;]}&#39;)
                    # min/max not in addition to valid_list
                    elif any(key in self.settings.keys() for key in MINMAXKEYS):
                        for key in MINMAXKEYS:
                            data = self._check_min_max(data, key, key[-3:] == &#39;min&#39;, key[:5] == &#39;force&#39;)

            except Exception as e:
                raise ValueError(f&#39;Given invalid value for command {self.name} due to settings. Error was: {e}&#39;)

        return data</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="multidevice.MD_Command.MD_Command_JSON" href="#multidevice.MD_Command.MD_Command_JSON">MD_Command_JSON</a></li>
<li><a title="multidevice.MD_Command.MD_Command_Str" href="#multidevice.MD_Command.MD_Command_Str">MD_Command_Str</a></li>
<li><a title="multidevice.MD_Command.MD_Command_Viessmann" href="#multidevice.MD_Command.MD_Command_Viessmann">MD_Command_Viessmann</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="multidevice.MD_Command.MD_Command.device_id"><code class="name">var <span class="ident">device_id</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="multidevice.MD_Command.MD_Command.item_type"><code class="name">var <span class="ident">item_type</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="multidevice.MD_Command.MD_Command.lookup"><code class="name">var <span class="ident">lookup</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="multidevice.MD_Command.MD_Command.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="multidevice.MD_Command.MD_Command.opcode"><code class="name">var <span class="ident">opcode</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="multidevice.MD_Command.MD_Command.read"><code class="name">var <span class="ident">read</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="multidevice.MD_Command.MD_Command.read_cmd"><code class="name">var <span class="ident">read_cmd</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="multidevice.MD_Command.MD_Command.reply_pattern"><code class="name">var <span class="ident">reply_pattern</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="multidevice.MD_Command.MD_Command.reply_token"><code class="name">var <span class="ident">reply_token</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="multidevice.MD_Command.MD_Command.settings"><code class="name">var <span class="ident">settings</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="multidevice.MD_Command.MD_Command.write"><code class="name">var <span class="ident">write</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="multidevice.MD_Command.MD_Command.write_cmd"><code class="name">var <span class="ident">write_cmd</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="multidevice.MD_Command.MD_Command.get_lookup"><code class="name flex">
<span>def <span class="ident">get_lookup</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>getter for lookup</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_lookup(self):
    &#34;&#34;&#34; getter for lookup &#34;&#34;&#34;
    return self.lookup</code></pre>
</details>
</dd>
<dt id="multidevice.MD_Command.MD_Command.get_send_data"><code class="name flex">
<span>def <span class="ident">get_send_data</span></span>(<span>self, data, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_send_data(self, data, **kwargs):

    cmd = None

    data = self._check_value(data)

    # create read data
    if data is None:
        if self.read_cmd:
            cmd = self.read_cmd
        else:
            cmd = self.opcode
    else:
        if self.write_cmd:
            cmd = self.write_cmd
        else:
            cmd = self.opcode

    return {&#39;payload&#39;: cmd, &#39;data&#39;: self._DT.get_send_data(data)}</code></pre>
</details>
</dd>
<dt id="multidevice.MD_Command.MD_Command.get_shng_data"><code class="name flex">
<span>def <span class="ident">get_shng_data</span></span>(<span>self, data, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_shng_data(self, data, **kwargs):
    value = self._DT.get_shng_data(data, **kwargs)
    return value</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="multidevice.MD_Command.MD_Command_JSON"><code class="flex name class">
<span>class <span class="ident">MD_Command_JSON</span></span>
<span>(</span><span>device_id, command, dt_class, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Command for JSON-RPC communication</p>
<p>With this class, you can send JSON-RPC commands to the device and read
from it.</p>
<p>The command is sent as 'method', the params-dict is populated from the
CMD_ATTR_PARAMS attribute of the command, while the parameter values are
taken from the CMD_ATTR_PARAM_VALUES attribute. 'VAL' is replaced with the
actual item value.</p>
<p>params and param_value need to be None or lists of the same length.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MD_Command_JSON(MD_Command):
    &#34;&#34;&#34; Command for JSON-RPC communication

    With this class, you can send JSON-RPC commands to the device and read
    from it.

    The command is sent as &#39;method&#39;, the params-dict is populated from the
    CMD_ATTR_PARAMS attribute of the command, while the parameter values are
    taken from the CMD_ATTR_PARAM_VALUES attribute. &#39;VAL&#39; is replaced with the
    actual item value.

    params and param_value need to be None or lists of the same length.
    &#34;&#34;&#34;

    def get_send_data(self, data, **kwargs):

        cmd = None
        data = self._check_value(data)
        # create read data
        if data is None:
            if self.read_cmd:
                cmd = self.read_cmd
            else:
                cmd = self.opcode
        else:
            if self.write_cmd:
                cmd = self.write_cmd
            else:
                cmd = self.opcode
        ddict = self._build_dict(self._DT.get_send_data(data), **kwargs)
        return {&#39;payload&#39;: cmd, &#39;data&#39;: ddict}

    def get_shng_data(self, data, **kwargs):
        value = self._DT.get_shng_data(data.get(&#39;result&#39;), **kwargs)
        return value

    def _build_dict(self, data, **kwargs):
        &#34;&#34;&#34;
        build param array for JSON RPC from provided value and kwargs

        :param data: value for the command
        :param kwargs: additional data
        :return: params-dict (or None)
        :rtype: dict
        &#34;&#34;&#34;
        params = {}
        if not hasattr(self, CMD_ATTR_PARAMS):
            return None

        if not hasattr(self, CMD_ATTR_PARAM_VALUES):
            raise SyntaxError(f&#39;params {kwargs[&#34;params&#34;]} given, but no param_values&#39;)

        if len(self.params) != len(self.param_values):
            raise SyntaxError(f&#39;different number of params and values given ({self.params}/{self.param_values})&#39;)

        for idx in range(len(self.params)):
            val = self.param_values[idx]
            if val == &#39;VAL&#39;:
                val = data
            elif isinstance(val, tuple):
                try:
                    expr = str(val[0]).replace(&#39;VAL&#39;, str(data))
                    val = eval(expr)
                except Exception as e:
                    raise ValueError(f&#39;invalid data: eval expression {val} with argument {data} raised error: {e}&#39;)

            params[self.params[idx]] = val

        if &#39;playerid&#39; in params and &#39;playerid&#39; in kwargs:
            params[&#39;playerid&#39;] = kwargs[&#39;playerid&#39;]

        return params</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="multidevice.MD_Command.MD_Command" href="#multidevice.MD_Command.MD_Command">MD_Command</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="multidevice.MD_Command.MD_Command_JSON.get_send_data"><code class="name flex">
<span>def <span class="ident">get_send_data</span></span>(<span>self, data, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_send_data(self, data, **kwargs):

    cmd = None
    data = self._check_value(data)
    # create read data
    if data is None:
        if self.read_cmd:
            cmd = self.read_cmd
        else:
            cmd = self.opcode
    else:
        if self.write_cmd:
            cmd = self.write_cmd
        else:
            cmd = self.opcode
    ddict = self._build_dict(self._DT.get_send_data(data), **kwargs)
    return {&#39;payload&#39;: cmd, &#39;data&#39;: ddict}</code></pre>
</details>
</dd>
<dt id="multidevice.MD_Command.MD_Command_JSON.get_shng_data"><code class="name flex">
<span>def <span class="ident">get_shng_data</span></span>(<span>self, data, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_shng_data(self, data, **kwargs):
    value = self._DT.get_shng_data(data.get(&#39;result&#39;), **kwargs)
    return value</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="multidevice.MD_Command.MD_Command" href="#multidevice.MD_Command.MD_Command">MD_Command</a></b></code>:
<ul class="hlist">
<li><code><a title="multidevice.MD_Command.MD_Command.get_lookup" href="#multidevice.MD_Command.MD_Command.get_lookup">get_lookup</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="multidevice.MD_Command.MD_Command_ParseStr"><code class="flex name class">
<span>class <span class="ident">MD_Command_ParseStr</span></span>
<span>(</span><span>device_id, command, dt_class, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Command for string-based communication with parsed arguments</p>
<p>With this class, you can simplify the creation of read and write commands
containing data values.</p>
<p>Default behaviour is identical to MD_Command_Str.</p>
<p>Giving write_cmd as ':<write expression>:' (note colons) will format the
given string (without the colons), replacing 'VAL' with the value by using
write_cmd.format(VAL=data_dict['payload']), so you can immediately embed
the value in the command string with configurable formatting conforming
to str.format() syntax.
If you have to start and end the command string with colons, just use
'::foo::' as write_cmd. If you absolutely HAVE to use a literal
':foo{VAL}bar:', you might need to write your own class&hellip;</p>
<p>Giving reply_pattern as '<regex>' with one (1) match group will try and
capture the matched group into the received value.</p>
<p>Giving reply_pattern as '<regex>' without capturing parentheses will return
the reply value as is (can possibly be converted by the DT class).</p>
<p>HINT: If you give reply_pattern as regex and reply_token as 'REGEX', the
reply_pattern regex will be used to identify a reply as belonging to this
command if a match is found.</p>
<p>Both results can be achieved with customized DT_foo classes, but this
might be an easier and cleaner solution. Please make sure to understand
MRE by JF properly :)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MD_Command_ParseStr(MD_Command_Str):
    &#34;&#34;&#34; Command for string-based communication with parsed arguments

    With this class, you can simplify the creation of read and write commands
    containing data values.

    Default behaviour is identical to MD_Command_Str.

    Giving write_cmd as &#39;:&lt;write expression&gt;:&#39; (note colons) will format the
    given string (without the colons), replacing &#39;VAL&#39; with the value by using
    write_cmd.format(VAL=data_dict[&#39;payload&#39;]), so you can immediately embed
    the value in the command string with configurable formatting conforming
    to str.format() syntax.
    If you have to start and end the command string with colons, just use
    &#39;::foo::&#39; as write_cmd. If you absolutely HAVE to use a literal
    &#39;:foo{VAL}bar:&#39;, you might need to write your own class...

    Giving reply_pattern as &#39;&lt;regex&gt;&#39; with one (1) match group will try and
    capture the matched group into the received value.

    Giving reply_pattern as &#39;&lt;regex&gt;&#39; without capturing parentheses will return
    the reply value as is (can possibly be converted by the DT class).

    HINT: If you give reply_pattern as regex and reply_token as &#39;REGEX&#39;, the
    reply_pattern regex will be used to identify a reply as belonging to this
    command if a match is found.

    Both results can be achieved with customized DT_foo classes, but this
    might be an easier and cleaner solution. Please make sure to understand
    MRE by JF properly :)
    &#34;&#34;&#34;

    def get_send_data(self, data, **kwargs):

        data = self._check_value(data)

        if data is None:
            # create read data
            if self.read_cmd:
                cmd_str = self._parse_str(self.read_cmd)
            else:
                cmd_str = self._parse_str(self.opcode, data)
        else:
            # create write data
            if self.write_cmd:
                # test if write_cmd is &#39;:foo:&#39; to trigger formatting/substitution
                # reminder: &#39;:val:&#39; replaces val with &#39;raw&#39; val, &#39;MD_VALUE&#39; uses DT.get_send_data(val)
                if self.write_cmd[0] == &#39;:&#39; and self.write_cmd[-1] == &#39;:&#39;:
                    if isinstance(data, str):
                        cmd_str = self._parse_str(self.write_cmd[1:-1].format(VAL=data, VAL_UPPER=data.upper(), VAL_LOWER=data.lower(), VAL_CAP=data.capitalize()), data)
                    else:
                        cmd_str = self._parse_str(self.write_cmd[1:-1].format(VAL=data))
                else:
                    cmd_str = self._parse_str(self.write_cmd, data)
            else:
                cmd_str = self._parse_str(self.opcode, data)

        return {&#39;payload&#39;: cmd_str, &#39;data&#39;: None if data is None else self._DT.get_send_data(data)}

    def get_shng_data(self, data, **kwargs):
        &#34;&#34;&#34;
        Try to match data to reply_pattern if reply_pattern is set.

        If a match is found and a value is captured, it will be returned.

        If a match is found without a capturing group, the value will be
        returned as-is, possibly to be converted by the DT class.

        If no match can be achieved, it is not possible to return
        a meaningful value. To signal the error, an exception will be raised.
        &#34;&#34;&#34;
        if isinstance(data, (bytes, bytearray)):
            data = data.decode(&#39;utf-8&#39;)

        self.logger.debug(f&#39;parse_str command got data {data} of type {type(data)}&#39;)

        if self.reply_pattern:
            regex = re.compile(self.reply_pattern)
            match = regex.match(data)
            if match:
                if len(match.groups()) == 1:

                    # one captured group - ok
                    value = self._DT.get_shng_data(match.group(1), **kwargs)
                elif len(match.groups()) &gt; 1:

                    # more than one captured group - error
                    raise ValueError(f&#39;reply_pattern {self.reply_pattern} has more than one pair of capturing parentheses&#39;)
                else:

                    # no captured groups = no parentheses = no extraction of value, just do the &#34;normal&#34; thing
                    value = self._DT.get_shng_data(data, **kwargs)
            else:
                raise ValueError(f&#39;reply_pattern {self.reply_pattern} could not get a match on {data}&#39;)
        else:
            value = self._DT.get_shng_data(data, **kwargs)
        return value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="multidevice.MD_Command.MD_Command_Str" href="#multidevice.MD_Command.MD_Command_Str">MD_Command_Str</a></li>
<li><a title="multidevice.MD_Command.MD_Command" href="#multidevice.MD_Command.MD_Command">MD_Command</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="multidevice.MD_Command.MD_Command_ParseStr.get_send_data"><code class="name flex">
<span>def <span class="ident">get_send_data</span></span>(<span>self, data, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_send_data(self, data, **kwargs):

    data = self._check_value(data)

    if data is None:
        # create read data
        if self.read_cmd:
            cmd_str = self._parse_str(self.read_cmd)
        else:
            cmd_str = self._parse_str(self.opcode, data)
    else:
        # create write data
        if self.write_cmd:
            # test if write_cmd is &#39;:foo:&#39; to trigger formatting/substitution
            # reminder: &#39;:val:&#39; replaces val with &#39;raw&#39; val, &#39;MD_VALUE&#39; uses DT.get_send_data(val)
            if self.write_cmd[0] == &#39;:&#39; and self.write_cmd[-1] == &#39;:&#39;:
                if isinstance(data, str):
                    cmd_str = self._parse_str(self.write_cmd[1:-1].format(VAL=data, VAL_UPPER=data.upper(), VAL_LOWER=data.lower(), VAL_CAP=data.capitalize()), data)
                else:
                    cmd_str = self._parse_str(self.write_cmd[1:-1].format(VAL=data))
            else:
                cmd_str = self._parse_str(self.write_cmd, data)
        else:
            cmd_str = self._parse_str(self.opcode, data)

    return {&#39;payload&#39;: cmd_str, &#39;data&#39;: None if data is None else self._DT.get_send_data(data)}</code></pre>
</details>
</dd>
<dt id="multidevice.MD_Command.MD_Command_ParseStr.get_shng_data"><code class="name flex">
<span>def <span class="ident">get_shng_data</span></span>(<span>self, data, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Try to match data to reply_pattern if reply_pattern is set.</p>
<p>If a match is found and a value is captured, it will be returned.</p>
<p>If a match is found without a capturing group, the value will be
returned as-is, possibly to be converted by the DT class.</p>
<p>If no match can be achieved, it is not possible to return
a meaningful value. To signal the error, an exception will be raised.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_shng_data(self, data, **kwargs):
    &#34;&#34;&#34;
    Try to match data to reply_pattern if reply_pattern is set.

    If a match is found and a value is captured, it will be returned.

    If a match is found without a capturing group, the value will be
    returned as-is, possibly to be converted by the DT class.

    If no match can be achieved, it is not possible to return
    a meaningful value. To signal the error, an exception will be raised.
    &#34;&#34;&#34;
    if isinstance(data, (bytes, bytearray)):
        data = data.decode(&#39;utf-8&#39;)

    self.logger.debug(f&#39;parse_str command got data {data} of type {type(data)}&#39;)

    if self.reply_pattern:
        regex = re.compile(self.reply_pattern)
        match = regex.match(data)
        if match:
            if len(match.groups()) == 1:

                # one captured group - ok
                value = self._DT.get_shng_data(match.group(1), **kwargs)
            elif len(match.groups()) &gt; 1:

                # more than one captured group - error
                raise ValueError(f&#39;reply_pattern {self.reply_pattern} has more than one pair of capturing parentheses&#39;)
            else:

                # no captured groups = no parentheses = no extraction of value, just do the &#34;normal&#34; thing
                value = self._DT.get_shng_data(data, **kwargs)
        else:
            raise ValueError(f&#39;reply_pattern {self.reply_pattern} could not get a match on {data}&#39;)
    else:
        value = self._DT.get_shng_data(data, **kwargs)
    return value</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="multidevice.MD_Command.MD_Command_Str" href="#multidevice.MD_Command.MD_Command_Str">MD_Command_Str</a></b></code>:
<ul class="hlist">
<li><code><a title="multidevice.MD_Command.MD_Command_Str.get_lookup" href="#multidevice.MD_Command.MD_Command.get_lookup">get_lookup</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="multidevice.MD_Command.MD_Command_Str"><code class="flex name class">
<span>class <span class="ident">MD_Command_Str</span></span>
<span>(</span><span>device_id, command, dt_class, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Command for string-based communication</p>
<p>This class represents a command which uses a string with arguments as payload,
for example as query URL.</p>
<p>Default behaviour is identical to MD_Command_Str.</p>
<p>For sending, the read_cmd/write_cmd strings, opcode and data are parsed
(recursively), to enable the following parameters:</p>
<ul>
<li>'MD_OPCODE' is replaced with the opcode,</li>
<li>'MD_PARAM:attr:' is replaced with the value of the attr element from the plugin configuration,</li>
<li>'MD_VALUE' is replaced with the given value (converted by DT-class)</li>
</ul>
<p>The returned data is only parsed by the DT_&hellip; classes.
For the DT_json class, the read_data dict can be used to extract a specific
element from a json response:</p>
<p><code>read_data = {'dict': ['key1', 'key2', 'key3']}</code></p>
<p>would try to get</p>
<p><code>json_response['key1']['key2']['key3']</code></p>
<p>and return it as the read value.</p>
<p>This class is provided as a reference implementation for the Net-Connections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MD_Command_Str(MD_Command):
    &#34;&#34;&#34; Command for string-based communication

    This class represents a command which uses a string with arguments as payload,
    for example as query URL.

    Default behaviour is identical to MD_Command_Str.

    For sending, the read_cmd/write_cmd strings, opcode and data are parsed
    (recursively), to enable the following parameters:

    - &#39;MD_OPCODE&#39; is replaced with the opcode,
    - &#39;MD_PARAM:attr:&#39; is replaced with the value of the attr element from the plugin configuration,
    - &#39;MD_VALUE&#39; is replaced with the given value (converted by DT-class)

    The returned data is only parsed by the DT_... classes.
    For the DT_json class, the read_data dict can be used to extract a specific
    element from a json response:

    ``read_data = {&#39;dict&#39;: [&#39;key1&#39;, &#39;key2&#39;, &#39;key3&#39;]}``

    would try to get

    ``json_response[&#39;key1&#39;][&#39;key2&#39;][&#39;key3&#39;]``

    and return it as the read value.

    This class is provided as a reference implementation for the Net-Connections.
    &#34;&#34;&#34;
    read_data = None

    def get_send_data(self, data, **kwargs):

        data = self._check_value(data)

        if data is None:
            # create read data
            if self.read_cmd:
                cmd_str = self._parse_str(self.read_cmd)
            else:
                cmd_str = self._parse_str(self.opcode, data)
        else:
            # create write data
            if self.write_cmd:
                cmd_str = self._parse_str(self.write_cmd, data)
            else:
                cmd_str = self._parse_str(self.opcode, data)

        data_dict = {}
        data_dict[&#39;payload&#39;] = cmd_str
        for k in self._plugin_params.keys():
            data_dict[k] = self._parse_tree(self.params[k], data)

        return data_dict

    def get_shng_data(self, data, **kwargs):
        if isinstance(data, (bytes, bytearray)):
            data = data.decode(&#39;utf-8&#39;)
        value = self._DT.get_shng_data(data, **kwargs)
        return value

    def _parse_str(self, string, data=None):
        &#34;&#34;&#34;
        parse string and replace
        - MD_OPCODE with the command opcode
        - MD_PARAM:&lt;elem&gt;: with the plugin parameter
        - MD_VALUE with the data value

        The replacement order ensures that MD_PARAM-patterns from the opcode
        can be replaced as well as MD_VALUE-pattern in any of the strings.
        &#34;&#34;&#34;
        def repl_func(matchobj):
            return str(self._plugin_params.get(matchobj.group(2), &#39;&#39;))

        string = string.replace(&#39;MD_OPCODE&#39;, self.opcode)

        regex = &#39;(MD_PARAM:([^:]+):)&#39;
        while re.match(&#39;.*&#39; + regex + &#39;.*&#39;, string):
            string = re.sub(regex, repl_func, string)

        if data is not None:
            string = string.replace(&#39;MD_VALUE&#39;, str(self._DT.get_send_data(data)))

        return string

    def _parse_tree(self, node, data):
        &#34;&#34;&#34;
        traverse node and
        - apply _parse_str to strings
        - recursively _parse_tree for all elements of iterables or
        - return unknown or unparseable elements unchanged
        &#34;&#34;&#34;
        if issubclass(node, str):
            return self._parse_str(node, data)
        elif issubclass(node, list):
            return [self._parse_tree(k, data) for k in node]
        elif issubclass(node, tuple):
            return (self._parse_tree(k, data) for k in node)
        elif issubclass(node, dict):
            new_dict = {}
            for k in node.keys():
                new_dict[k] = self._parse_tree(node[k], data)
            return new_dict
        else:
            return node</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="multidevice.MD_Command.MD_Command" href="#multidevice.MD_Command.MD_Command">MD_Command</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="multidevice.MD_Command.MD_Command_ParseStr" href="#multidevice.MD_Command.MD_Command_ParseStr">MD_Command_ParseStr</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="multidevice.MD_Command.MD_Command_Str.read_data"><code class="name">var <span class="ident">read_data</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="multidevice.MD_Command.MD_Command_Str.get_send_data"><code class="name flex">
<span>def <span class="ident">get_send_data</span></span>(<span>self, data, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_send_data(self, data, **kwargs):

    data = self._check_value(data)

    if data is None:
        # create read data
        if self.read_cmd:
            cmd_str = self._parse_str(self.read_cmd)
        else:
            cmd_str = self._parse_str(self.opcode, data)
    else:
        # create write data
        if self.write_cmd:
            cmd_str = self._parse_str(self.write_cmd, data)
        else:
            cmd_str = self._parse_str(self.opcode, data)

    data_dict = {}
    data_dict[&#39;payload&#39;] = cmd_str
    for k in self._plugin_params.keys():
        data_dict[k] = self._parse_tree(self.params[k], data)

    return data_dict</code></pre>
</details>
</dd>
<dt id="multidevice.MD_Command.MD_Command_Str.get_shng_data"><code class="name flex">
<span>def <span class="ident">get_shng_data</span></span>(<span>self, data, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_shng_data(self, data, **kwargs):
    if isinstance(data, (bytes, bytearray)):
        data = data.decode(&#39;utf-8&#39;)
    value = self._DT.get_shng_data(data, **kwargs)
    return value</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="multidevice.MD_Command.MD_Command" href="#multidevice.MD_Command.MD_Command">MD_Command</a></b></code>:
<ul class="hlist">
<li><code><a title="multidevice.MD_Command.MD_Command.get_lookup" href="#multidevice.MD_Command.MD_Command.get_lookup">get_lookup</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="multidevice.MD_Command.MD_Command_Viessmann"><code class="flex name class">
<span>class <span class="ident">MD_Command_Viessmann</span></span>
<span>(</span><span>device_id, command, dt_class, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Command for Viessmann binary command format</p>
<p>With this class, you can send commands to Viessmann heating systems</p>
<p>The command is sent as 'method', the params-dict is populated from the
CMD_ATTR_PARAMS attribute of the command, while the parameter values are
taken from the CMD_ATTR_PARAM_VALUES attribute. 'VAL' is replaced with the
actual item value.</p>
<p>params and param_value need to be None or lists of the same length.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MD_Command_Viessmann(MD_Command):
    &#34;&#34;&#34; Command for Viessmann binary command format

    With this class, you can send commands to Viessmann heating systems

    The command is sent as &#39;method&#39;, the params-dict is populated from the
    CMD_ATTR_PARAMS attribute of the command, while the parameter values are
    taken from the CMD_ATTR_PARAM_VALUES attribute. &#39;VAL&#39; is replaced with the
    actual item value.

    params and param_value need to be None or lists of the same length.
    &#34;&#34;&#34;
    def __init__(self, device_id, command, dt_class, **kwargs):
        super().__init__(device_id, command, dt_class, **kwargs)

        self._len = 1
        self._mult = 0
        self._signed = False
        for attr in (&#39;len&#39;, &#39;mult&#39;, &#39;signed&#39;):
            if attr in self.params:
                setattr(self, &#39;_&#39; + attr, self.param_values[self.params.index(attr)])

    def get_send_data(self, data, **kwargs):

        data = self._check_value(data)
        # create read data
        if data is None:
            if self.read_cmd:
                cmd = self.read_cmd
            else:
                cmd = self.opcode
        else:
            if self.write_cmd:
                cmd = self.write_cmd
            else:
                cmd = self.opcode

        ddict = self._build_dict(self._DT.get_send_data(data, len=self._len, mult=self._mult, signed=self._signed), **kwargs)
        return {&#39;payload&#39;: cmd, &#39;data&#39;: ddict}

    def _build_dict(self, data, **kwargs):
        &#34;&#34;&#34;
        build param array for JSON RPC from provided value and kwargs

        :param data: value for the command
        :param kwargs: additional data
        :return: params-dict (or None)
        :rtype: dict
        &#34;&#34;&#34;
        params = {}
        if not hasattr(self, CMD_ATTR_PARAMS):
            return None

        if not hasattr(self, CMD_ATTR_PARAM_VALUES):
            raise SyntaxError(f&#39;params {kwargs[&#34;params&#34;]} given, but no param_values&#39;)

        if len(self.params) != len(self.param_values):
            raise SyntaxError(f&#39;different number of params and values given ({self.params}/{self.param_values})&#39;)

        for idx in range(len(self.params)):
            val = self.param_values[idx]
            if val == &#39;VAL&#39;:
                val = data
            elif isinstance(val, tuple):
                try:
                    expr = str(val[0]).replace(&#39;VAL&#39;, str(data))
                    val = eval(expr)
                except Exception as e:
                    raise ValueError(f&#39;invalid data: eval expression {val} with argument {data} raised error: {e}&#39;)

            params[self.params[idx]] = val

        return params</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="multidevice.MD_Command.MD_Command" href="#multidevice.MD_Command.MD_Command">MD_Command</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="multidevice.MD_Command.MD_Command_Viessmann.get_send_data"><code class="name flex">
<span>def <span class="ident">get_send_data</span></span>(<span>self, data, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_send_data(self, data, **kwargs):

    data = self._check_value(data)
    # create read data
    if data is None:
        if self.read_cmd:
            cmd = self.read_cmd
        else:
            cmd = self.opcode
    else:
        if self.write_cmd:
            cmd = self.write_cmd
        else:
            cmd = self.opcode

    ddict = self._build_dict(self._DT.get_send_data(data, len=self._len, mult=self._mult, signed=self._signed), **kwargs)
    return {&#39;payload&#39;: cmd, &#39;data&#39;: ddict}</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="multidevice.MD_Command.MD_Command" href="#multidevice.MD_Command.MD_Command">MD_Command</a></b></code>:
<ul class="hlist">
<li><code><a title="multidevice.MD_Command.MD_Command.get_lookup" href="#multidevice.MD_Command.MD_Command.get_lookup">get_lookup</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="multidevice" href="index.html">multidevice</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="multidevice.MD_Command.MD_Command" href="#multidevice.MD_Command.MD_Command">MD_Command</a></code></h4>
<ul class="two-column">
<li><code><a title="multidevice.MD_Command.MD_Command.device_id" href="#multidevice.MD_Command.MD_Command.device_id">device_id</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command.get_lookup" href="#multidevice.MD_Command.MD_Command.get_lookup">get_lookup</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command.get_send_data" href="#multidevice.MD_Command.MD_Command.get_send_data">get_send_data</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command.get_shng_data" href="#multidevice.MD_Command.MD_Command.get_shng_data">get_shng_data</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command.item_type" href="#multidevice.MD_Command.MD_Command.item_type">item_type</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command.lookup" href="#multidevice.MD_Command.MD_Command.lookup">lookup</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command.name" href="#multidevice.MD_Command.MD_Command.name">name</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command.opcode" href="#multidevice.MD_Command.MD_Command.opcode">opcode</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command.read" href="#multidevice.MD_Command.MD_Command.read">read</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command.read_cmd" href="#multidevice.MD_Command.MD_Command.read_cmd">read_cmd</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command.reply_pattern" href="#multidevice.MD_Command.MD_Command.reply_pattern">reply_pattern</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command.reply_token" href="#multidevice.MD_Command.MD_Command.reply_token">reply_token</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command.settings" href="#multidevice.MD_Command.MD_Command.settings">settings</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command.write" href="#multidevice.MD_Command.MD_Command.write">write</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command.write_cmd" href="#multidevice.MD_Command.MD_Command.write_cmd">write_cmd</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="multidevice.MD_Command.MD_Command_JSON" href="#multidevice.MD_Command.MD_Command_JSON">MD_Command_JSON</a></code></h4>
<ul class="">
<li><code><a title="multidevice.MD_Command.MD_Command_JSON.get_send_data" href="#multidevice.MD_Command.MD_Command_JSON.get_send_data">get_send_data</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command_JSON.get_shng_data" href="#multidevice.MD_Command.MD_Command_JSON.get_shng_data">get_shng_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="multidevice.MD_Command.MD_Command_ParseStr" href="#multidevice.MD_Command.MD_Command_ParseStr">MD_Command_ParseStr</a></code></h4>
<ul class="">
<li><code><a title="multidevice.MD_Command.MD_Command_ParseStr.get_send_data" href="#multidevice.MD_Command.MD_Command_ParseStr.get_send_data">get_send_data</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command_ParseStr.get_shng_data" href="#multidevice.MD_Command.MD_Command_ParseStr.get_shng_data">get_shng_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="multidevice.MD_Command.MD_Command_Str" href="#multidevice.MD_Command.MD_Command_Str">MD_Command_Str</a></code></h4>
<ul class="">
<li><code><a title="multidevice.MD_Command.MD_Command_Str.get_send_data" href="#multidevice.MD_Command.MD_Command_Str.get_send_data">get_send_data</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command_Str.get_shng_data" href="#multidevice.MD_Command.MD_Command_Str.get_shng_data">get_shng_data</a></code></li>
<li><code><a title="multidevice.MD_Command.MD_Command_Str.read_data" href="#multidevice.MD_Command.MD_Command_Str.read_data">read_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="multidevice.MD_Command.MD_Command_Viessmann" href="#multidevice.MD_Command.MD_Command_Viessmann">MD_Command_Viessmann</a></code></h4>
<ul class="">
<li><code><a title="multidevice.MD_Command.MD_Command_Viessmann.get_send_data" href="#multidevice.MD_Command.MD_Command_Viessmann.get_send_data">get_send_data</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>