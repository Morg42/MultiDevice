<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>multidevice.MD_Commands API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>multidevice.MD_Commands</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# vim: set encoding=utf-8 tabstop=4 softtabstop=4 shiftwidth=4 expandtab
#########################################################################
#  Copyright 2020-      Sebastian Helms             Morg @ knx-user-forum
#########################################################################
#  This file aims to become part of SmartHomeNG.
#  https://www.smarthomeNG.de
#  https://knx-user-forum.de/forum/supportforen/smarthome-py
#
#  MD_Commands for MultiDevice plugin
#
#  SmartHomeNG is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  SmartHomeNG is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with SmartHomeNG. If not, see &lt;http://www.gnu.org/licenses/&gt;.
#
#########################################################################

import logging
import re
from pydoc import locate

if MD_standalone:
    from MD_Globals import *
    from MD_Command import MD_Command
    import datatypes as DT
else:
    from .MD_Globals import *
    from .MD_Command import MD_Command
    from . import datatypes as DT


#############################################################################################################################################################################################################################################
#
# class MD_Commands
#
#############################################################################################################################################################################################################################################

class MD_Commands(object):
    &#39;&#39;&#39;
    This class represents a command list to save some error handling code on
    every access (in comparison to using a dict). Not much more functionality
    here, most calls check for errors and pass thru the request to the selected
    MD_Command-object

    Furthermore, this could be overloaded if so needed for special extensions.
    &#39;&#39;&#39;
    def __init__(self, device_type, device_id, command_obj_class=MD_Command, **kwargs):

        # get MultiDevice.device logger
        self.logger = logging.getLogger(&#39;.&#39;.join(__name__.split(&#39;.&#39;)[:-1]) + f&#39;.{device_id}&#39;)

        self.logger.debug(f&#39;commands initializing from {command_obj_class.__name__}&#39;)
        self._commands = None         # { &#39;cmd_x&#39;: MD_Command(params), ... }
        self._lookups = {}          # { &#39;name_x&#39;: {&#39;fwd&#39;: {&#39;K1&#39;: &#39;V1&#39;, ...}, &#39;rev&#39;: {&#39;V1&#39;: &#39;K1&#39;, ...}, &#39;rci&#39;: {&#39;v1&#39;: &#39;K1&#39;, ...}}}
        self._lookup_tables = []
        self.device_id = device_id
        self._device_type = device_type
        self._cmd_class = command_obj_class
        self._plugin_params = {}
        self._plugin_params.update(kwargs)

        self._model = self._plugin_params.get(&#39;model&#39;, None)

        self._dt = {}
        self._return_value = None
        self._read_dt_classes(device_type)
        if not self._read_commands(device_id):
            return None

        if self._commands is not None or MD_standalone:
            self.logger.debug(f&#39;{len(self._commands)} commands initialized&#39;)
        else:
            self.logger.error(&#39;commands could not be initialized&#39;)

    def is_valid_command(self, command, read=None):
        if command not in self._commands:
            return False

        if read is None:
            return True

        # if the corresponding attribute is not defined, assume False (fail safe)
        return getattr(self._commands[command], &#39;read&#39; if read else &#39;write&#39;, False)

    def get_send_data(self, command, data=None, **kwargs):
        if command in self._commands:
            lu = self._get_cmd_lookup(command)
            if lu:
                data = self._lookup(data, lu, rev=True)
            return self._commands[command].get_send_data(data, **kwargs)

        raise Exception(f&#39;command {command} not found in commands&#39;)

    def get_shng_data(self, command, data, **kwargs):
        if command in self._commands:
            result = self._commands[command].get_shng_data(data, **kwargs)
            lu = self._get_cmd_lookup(command)
            if lu:
                result = self._lookup(result, lu)
            return result

        raise Exception(f&#39;command {command} not found in commands&#39;)

    def get_command_from_reply(self, data):
        if type(data) in (bytes, bytearray):
            data = str(data.decode(&#39;utf-8&#39;))

        for command in self._commands:
            tokens = getattr(self._commands[command], &#39;reply_token&#39;, None)
            if tokens:
                if not isinstance(tokens, list):
                    tokens = [tokens]
                for token in tokens:
                    if token == &#39;REGEX&#39; and getattr(self._commands[command], &#39;reply_pattern&#39;, None):

                        # token is &#34;REGEX&#34; - parse read_cmd as regex
                        try:
                            regex = re.compile(getattr(self._commands[command], &#39;reply_pattern&#39;))
                            if regex.match(data) is not None:
                                self.logger.debug(f&#39;matched reply_pattern {getattr(self._commands[command], &#34;reply_pattern&#34;)} as regex against data {data}, found command {command}&#39;)
                                return command
                        except Exception as e:
                            self.logger.warning(f&#39;parsing or matching reply_pattern {getattr(self._commands[command], &#34;reply_pattern&#34;)} from command {command} as regex failed. Error was: {e}. Ignoring&#39;)
                    elif token != &#39;&#39; and token == data[:len(token)]:

                        # token ist just a string
                        return command
        return None

    def get_lookup(self, lookup, type=&#39;fwd&#39;):
        &#39;&#39;&#39; returns the contents of the lookup table named &lt;lookup&gt;, None on error &#39;&#39;&#39;
        if lookup in self._lookups and type in (&#39;fwd&#39;, &#39;rev&#39;, &#39;rci&#39;):
            return self._lookups[lookup][type]
        else:
            return None

    def _lookup(self, data, table, rev=False, ci=True):
        &#39;&#39;&#39;
        try to lookup data from lookup dict &lt;table&gt;

        normal mode is device data -&gt; shng data (rev=False, ci is ignored)
        reverse mode is shng data -&gt; device data (rev=True, ci=False)
        ci mode is reverse mode, but case insensitive lookup (rev=True, ci=True, default for rev)

        As data is used as key in dict lookups, it must be a hashable type (num, int, float, str)

        Per definition, data can be None, e.g. for read commands. In this case, return None

        On success, lookup result is returned. On error, an exception is raised.

        :param data: data to look up
        :param table: name of lookup dict
        :param rev: reverse mode (see above)
        :param ci: case insensitive reverse mode (see above)
        :type table: str
        :type rev: bool
        :type ci: bool
        :return: lookup result
        &#39;&#39;&#39;
        if data is None:
            return None

        mode = &#39;fwd&#39;
        if rev:
            mode = &#39;rci&#39; if ci else &#39;rev&#39;

        lu = self.get_lookup(table, mode)
        if not lu:
            raise ValueError(f&#39;Lookup table {table} not found.&#39;)

        if rev and ci and isinstance(data, str):
            data = data.lower()

        if data in lu:
            return lu[data]

        raise ValueError(f&#39;Lookup of value {data} in table {table} failed, entry not found.&#39;)            

    def _get_cmd_lookup(self, command):
        &#39;&#39;&#39; returns lookup name for command or None &#39;&#39;&#39;
        if command in self._commands:
            return self._commands[command].get_lookup()

        raise Exception(f&#39;command {command} not found in commands&#39;)

    def _read_dt_classes(self, device_type):
        &#39;&#39;&#39;
        This method enumerates all classes named &#39;DT_*&#39; from the Datatypes module
        and tries to load custom &#39;DT_*&#39; classes from the device&#39;s subdirectory
        datatypes.py file and collect all in the self._dt dict.
        Integrating custom classes into the DT module would change this for all
        loaded devices and name collisions could not be resolved.
        &#39;&#39;&#39;
        def _enum_dt_cls(mod):
            classes = [cls for cls in dir(mod) if cls[:3] == &#39;DT_&#39;]
            for cls in classes:
                self._dt[cls] = getattr(mod, cls)

        self._dt[&#39;Datatype&#39;] = DT.Datatype

        # enumerate &#39;DT_*&#39; classes from DT
        _enum_dt_cls(DT)

        # try to load datatypes.py from device directory
        mod_str = &#39;dev_&#39; + device_type + &#39;.datatypes&#39;
        if not MD_standalone:
            mod_str = &#39;.&#39;.join(self.__module__.split(&#39;.&#39;)[:-1]) + &#39;.&#39; + mod_str

        cust_mod = locate(mod_str)
        if cust_mod:
            _enum_dt_cls(cust_mod)

    def _read_commands(self, device_id):
        &#39;&#39;&#39;
        This is the loader portion for the commands.py file.

        Errors preventing the device from working raise `Exception`
        &#39;&#39;&#39;
        # did we get a device type?
        if not self._device_type:
            raise Exception(&#39;device_type not set, not reading commands&#39;)

        # try to load commands.py from device directory
        mod_str = &#39;dev_&#39; + self._device_type + &#39;.commands&#39;
        if not MD_standalone:
            mod_str = &#39;.&#39;.join(self.__module__.split(&#39;.&#39;)[:-1]) + &#39;.&#39; + mod_str

        try:
            # get module
            cmd_module = locate(mod_str)
        except ImportError:
            raise CommandsError(f&#39;importing external module {&#34;dev_&#34; + self._device_type + &#34;/commands.py&#34;} failed&#39;)
        except Exception as e:
            raise CommandsError(f&#39;importing commands from external module {&#34;dev_&#34; + self._device_type + &#34;/commands.py&#34;} failed. Error was: &#34;{e}&#34;&#39;)
            return False

        if self._model:
            if hasattr(cmd_module, &#39;models&#39;):
                if isinstance(cmd_module.models, dict):
                    if self._model in cmd_module.models:
                        self.logger.info(f&#39;model {self._model} identified&#39;)
                    else: 
                        raise CommandsError(f&#39;configured model {self._model} not found in commands.py models {cmd_module.models.keys()}&#39;)
                else:
                    raise CommandsError(f&#39;model configuration for device type {self._device_type} invalid, &#34;models&#34; is not a dict&#39;)
            else:
                self.logger.warning(f&#39;plugin configuration wants model {self._model}, but device type {self._device_type} has no model configuration. Loading all commands...&#39;)
                self._model = None

        if hasattr(cmd_module, &#39;commands&#39;) and isinstance(cmd_module.commands, dict) and not MD_standalone:
            cmds = cmd_module.commands
            cmdlist = None
            if INDEX_GENERIC in cmds:
                if self._model in cmds[INDEX_GENERIC]:
                    cmds = cmds[INDEX_GENERIC][self._model]
                elif not self._model:
                    self.logger.debug(f&#39;model set to empty string, not loading commands. You have been warned...&#39;)
                    cmds = {}
                else:
                    raise CommandsError(f&#39;commands require configuration attribute &#34;model&#34;, but model {self._model + &#34; not set in commands dict&#34; if self._model else &#34;unknown&#34;}.&#39;)
            if self._model:
                cmdlist = cmd_module.models[self._model]
                self.logger.debug(f&#39;found {len(cmdlist)} commands for model {self._model}&#39;)
                if INDEX_GENERIC in cmd_module.models:
                    cmdlist += cmd_module.models[INDEX_GENERIC]
                    self.logger.debug(f&#39;found {len(cmd_module.models[INDEX_GENERIC])} generic commands&#39;)
            if cmdlist is None:
                cmdlist = cmds.keys()
            self._parse_commands(device_id, cmds, cmdlist)
        else:
            if not MD_standalone:
                self.logger.warning(&#39;no command definitions found. This device probably will not work...&#39;)

        if hasattr(cmd_module, &#39;lookups&#39;) and isinstance(cmd_module.lookups, dict):
            self._parse_lookups(device_id, cmd_module.lookups)
        else:
            self.logger.debug(&#39;no lookups found&#39;)

        return True

    def _parse_commands(self, device_id, commands, cmds=[]):
        &#39;&#39;&#39;
        This is a reference implementation for parsing the commands dict imported
        from the commands.py file in the device subdirectory.
        For special purposes, this can be overloaded, if you want to use your
        own file format.
        &#39;&#39;&#39;
        self._commands = {}

        for cmd in cmds:
            kw = {}
            for arg in COMMAND_PARAMS:
                if arg in commands[cmd]:
                    kw[arg] = commands[cmd][arg]

            # if valid_list_ci is present in settings, convert all str elements to lowercase only once
            if &#39;settings&#39; in kw:
                if &#39;valid_list_ci&#39; in kw[&#39;settings&#39;]:
                    kw[&#39;settings&#39;][&#39;valid_list_ci&#39;] = [entry.lower() if isinstance(entry, str) else entry for entry in kw[&#39;settings&#39;][&#39;valid_list_ci&#39;]]

            dt_class = None
            dev_datatype = kw.get(&#39;dev_datatype&#39;, &#39;&#39;)
            if dev_datatype:
                class_name = &#39;&#39; if dev_datatype[:2] == &#39;DT_&#39; else &#39;DT_&#39; + dev_datatype
                dt_class = self._dt.get(class_name)

            if kw.get(&#39;read&#39;, False) and kw.get(&#39;opcode&#39;, &#39;&#39;) == &#39;&#39; and kw.get(&#39;read_cmd&#39;, &#39;&#39;) == &#39;&#39;:
                self.logger.info(f&#39;command {cmd} will not create a command for reading values. Check commands.py configuration...&#39;)
            if kw.get(&#39;write&#39;, False) and kw.get(&#39;opcode&#39;, &#39;&#39;) == &#39;&#39; and kw.get(&#39;write_cmd&#39;, &#39;&#39;) == &#39;&#39;:
                self.logger.info(f&#39;command {cmd} will not create a command for writing values. Check commands.py configuration...&#39;)
            if not dt_class:
                self.logger.error(f&#39;importing command {cmd} found invalid datatype &#34;{dev_datatype}&#34;, replacing with DT_raw. Check function of device&#39;)
                dt_class = DT.DT_raw
            self._commands[cmd] = self._cmd_class(self.device_id, cmd, dt_class, **{&#39;cmd&#39;: kw, &#39;plugin&#39;: self._plugin_params})

    def _parse_lookups(self, device_id, lookups):
        &#39;&#39;&#39;
        This is a reference implementation for parsing the lookups dict imported
        from the commands.py file in the device subdirectory.
        For special purposes, this can be overloaded, if you want to use your
        own file format.
        &#39;&#39;&#39;
        if INDEX_GENERIC in lookups:
            lu = lookups[INDEX_GENERIC]
            self.logger.debug(f&#39;found {len(lu)} generic lookup table{&#34;&#34; if len(lu) == 1 else &#34;s&#34;}&#39;)

            if self._model and self._model in lookups:
                lu.update(lookups[self._model])
                self.logger.debug(f&#39;found {len(lookups[self._model])} lookup table{&#34;&#34; if len(lookups[self._model]) == 1 else &#34;s&#34;} for model {self._model}&#39;)
        else:
            lu = lookups

        for table in lu:
            if isinstance(lu[table], dict):

                self._lookups[table] = {}

                # original dict
                self._lookups[table][&#39;fwd&#39;] = lu[table]
                # reversed dict
                self._lookups[table][&#39;rev&#39;] = {v: k for (k, v) in lu[table].items()}
                # reversed dict, keys are lowercase for case insensitive lookup
                self._lookups[table][&#39;rci&#39;] = {v.lower() if isinstance(v, str) else v: k for (k, v) in lu[table].items()}

                self._lookup_tables.append(table)
                self.logger.debug(f&#39;imported lookup table {table} with {len(lu[table])} items&#39;)
            else:
                self.logger.warning(f&#39;key {table} in lookups not in dict format, ignoring&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="multidevice.MD_Commands.MD_Commands"><code class="flex name class">
<span>class <span class="ident">MD_Commands</span></span>
<span>(</span><span>device_type, device_id, command_obj_class=multidevice.MD_Command.MD_Command, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents a command list to save some error handling code on
every access (in comparison to using a dict). Not much more functionality
here, most calls check for errors and pass thru the request to the selected
MD_Command-object</p>
<p>Furthermore, this could be overloaded if so needed for special extensions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MD_Commands(object):
    &#39;&#39;&#39;
    This class represents a command list to save some error handling code on
    every access (in comparison to using a dict). Not much more functionality
    here, most calls check for errors and pass thru the request to the selected
    MD_Command-object

    Furthermore, this could be overloaded if so needed for special extensions.
    &#39;&#39;&#39;
    def __init__(self, device_type, device_id, command_obj_class=MD_Command, **kwargs):

        # get MultiDevice.device logger
        self.logger = logging.getLogger(&#39;.&#39;.join(__name__.split(&#39;.&#39;)[:-1]) + f&#39;.{device_id}&#39;)

        self.logger.debug(f&#39;commands initializing from {command_obj_class.__name__}&#39;)
        self._commands = None         # { &#39;cmd_x&#39;: MD_Command(params), ... }
        self._lookups = {}          # { &#39;name_x&#39;: {&#39;fwd&#39;: {&#39;K1&#39;: &#39;V1&#39;, ...}, &#39;rev&#39;: {&#39;V1&#39;: &#39;K1&#39;, ...}, &#39;rci&#39;: {&#39;v1&#39;: &#39;K1&#39;, ...}}}
        self._lookup_tables = []
        self.device_id = device_id
        self._device_type = device_type
        self._cmd_class = command_obj_class
        self._plugin_params = {}
        self._plugin_params.update(kwargs)

        self._model = self._plugin_params.get(&#39;model&#39;, None)

        self._dt = {}
        self._return_value = None
        self._read_dt_classes(device_type)
        if not self._read_commands(device_id):
            return None

        if self._commands is not None or MD_standalone:
            self.logger.debug(f&#39;{len(self._commands)} commands initialized&#39;)
        else:
            self.logger.error(&#39;commands could not be initialized&#39;)

    def is_valid_command(self, command, read=None):
        if command not in self._commands:
            return False

        if read is None:
            return True

        # if the corresponding attribute is not defined, assume False (fail safe)
        return getattr(self._commands[command], &#39;read&#39; if read else &#39;write&#39;, False)

    def get_send_data(self, command, data=None, **kwargs):
        if command in self._commands:
            lu = self._get_cmd_lookup(command)
            if lu:
                data = self._lookup(data, lu, rev=True)
            return self._commands[command].get_send_data(data, **kwargs)

        raise Exception(f&#39;command {command} not found in commands&#39;)

    def get_shng_data(self, command, data, **kwargs):
        if command in self._commands:
            result = self._commands[command].get_shng_data(data, **kwargs)
            lu = self._get_cmd_lookup(command)
            if lu:
                result = self._lookup(result, lu)
            return result

        raise Exception(f&#39;command {command} not found in commands&#39;)

    def get_command_from_reply(self, data):
        if type(data) in (bytes, bytearray):
            data = str(data.decode(&#39;utf-8&#39;))

        for command in self._commands:
            tokens = getattr(self._commands[command], &#39;reply_token&#39;, None)
            if tokens:
                if not isinstance(tokens, list):
                    tokens = [tokens]
                for token in tokens:
                    if token == &#39;REGEX&#39; and getattr(self._commands[command], &#39;reply_pattern&#39;, None):

                        # token is &#34;REGEX&#34; - parse read_cmd as regex
                        try:
                            regex = re.compile(getattr(self._commands[command], &#39;reply_pattern&#39;))
                            if regex.match(data) is not None:
                                self.logger.debug(f&#39;matched reply_pattern {getattr(self._commands[command], &#34;reply_pattern&#34;)} as regex against data {data}, found command {command}&#39;)
                                return command
                        except Exception as e:
                            self.logger.warning(f&#39;parsing or matching reply_pattern {getattr(self._commands[command], &#34;reply_pattern&#34;)} from command {command} as regex failed. Error was: {e}. Ignoring&#39;)
                    elif token != &#39;&#39; and token == data[:len(token)]:

                        # token ist just a string
                        return command
        return None

    def get_lookup(self, lookup, type=&#39;fwd&#39;):
        &#39;&#39;&#39; returns the contents of the lookup table named &lt;lookup&gt;, None on error &#39;&#39;&#39;
        if lookup in self._lookups and type in (&#39;fwd&#39;, &#39;rev&#39;, &#39;rci&#39;):
            return self._lookups[lookup][type]
        else:
            return None

    def _lookup(self, data, table, rev=False, ci=True):
        &#39;&#39;&#39;
        try to lookup data from lookup dict &lt;table&gt;

        normal mode is device data -&gt; shng data (rev=False, ci is ignored)
        reverse mode is shng data -&gt; device data (rev=True, ci=False)
        ci mode is reverse mode, but case insensitive lookup (rev=True, ci=True, default for rev)

        As data is used as key in dict lookups, it must be a hashable type (num, int, float, str)

        Per definition, data can be None, e.g. for read commands. In this case, return None

        On success, lookup result is returned. On error, an exception is raised.

        :param data: data to look up
        :param table: name of lookup dict
        :param rev: reverse mode (see above)
        :param ci: case insensitive reverse mode (see above)
        :type table: str
        :type rev: bool
        :type ci: bool
        :return: lookup result
        &#39;&#39;&#39;
        if data is None:
            return None

        mode = &#39;fwd&#39;
        if rev:
            mode = &#39;rci&#39; if ci else &#39;rev&#39;

        lu = self.get_lookup(table, mode)
        if not lu:
            raise ValueError(f&#39;Lookup table {table} not found.&#39;)

        if rev and ci and isinstance(data, str):
            data = data.lower()

        if data in lu:
            return lu[data]

        raise ValueError(f&#39;Lookup of value {data} in table {table} failed, entry not found.&#39;)            

    def _get_cmd_lookup(self, command):
        &#39;&#39;&#39; returns lookup name for command or None &#39;&#39;&#39;
        if command in self._commands:
            return self._commands[command].get_lookup()

        raise Exception(f&#39;command {command} not found in commands&#39;)

    def _read_dt_classes(self, device_type):
        &#39;&#39;&#39;
        This method enumerates all classes named &#39;DT_*&#39; from the Datatypes module
        and tries to load custom &#39;DT_*&#39; classes from the device&#39;s subdirectory
        datatypes.py file and collect all in the self._dt dict.
        Integrating custom classes into the DT module would change this for all
        loaded devices and name collisions could not be resolved.
        &#39;&#39;&#39;
        def _enum_dt_cls(mod):
            classes = [cls for cls in dir(mod) if cls[:3] == &#39;DT_&#39;]
            for cls in classes:
                self._dt[cls] = getattr(mod, cls)

        self._dt[&#39;Datatype&#39;] = DT.Datatype

        # enumerate &#39;DT_*&#39; classes from DT
        _enum_dt_cls(DT)

        # try to load datatypes.py from device directory
        mod_str = &#39;dev_&#39; + device_type + &#39;.datatypes&#39;
        if not MD_standalone:
            mod_str = &#39;.&#39;.join(self.__module__.split(&#39;.&#39;)[:-1]) + &#39;.&#39; + mod_str

        cust_mod = locate(mod_str)
        if cust_mod:
            _enum_dt_cls(cust_mod)

    def _read_commands(self, device_id):
        &#39;&#39;&#39;
        This is the loader portion for the commands.py file.

        Errors preventing the device from working raise `Exception`
        &#39;&#39;&#39;
        # did we get a device type?
        if not self._device_type:
            raise Exception(&#39;device_type not set, not reading commands&#39;)

        # try to load commands.py from device directory
        mod_str = &#39;dev_&#39; + self._device_type + &#39;.commands&#39;
        if not MD_standalone:
            mod_str = &#39;.&#39;.join(self.__module__.split(&#39;.&#39;)[:-1]) + &#39;.&#39; + mod_str

        try:
            # get module
            cmd_module = locate(mod_str)
        except ImportError:
            raise CommandsError(f&#39;importing external module {&#34;dev_&#34; + self._device_type + &#34;/commands.py&#34;} failed&#39;)
        except Exception as e:
            raise CommandsError(f&#39;importing commands from external module {&#34;dev_&#34; + self._device_type + &#34;/commands.py&#34;} failed. Error was: &#34;{e}&#34;&#39;)
            return False

        if self._model:
            if hasattr(cmd_module, &#39;models&#39;):
                if isinstance(cmd_module.models, dict):
                    if self._model in cmd_module.models:
                        self.logger.info(f&#39;model {self._model} identified&#39;)
                    else: 
                        raise CommandsError(f&#39;configured model {self._model} not found in commands.py models {cmd_module.models.keys()}&#39;)
                else:
                    raise CommandsError(f&#39;model configuration for device type {self._device_type} invalid, &#34;models&#34; is not a dict&#39;)
            else:
                self.logger.warning(f&#39;plugin configuration wants model {self._model}, but device type {self._device_type} has no model configuration. Loading all commands...&#39;)
                self._model = None

        if hasattr(cmd_module, &#39;commands&#39;) and isinstance(cmd_module.commands, dict) and not MD_standalone:
            cmds = cmd_module.commands
            cmdlist = None
            if INDEX_GENERIC in cmds:
                if self._model in cmds[INDEX_GENERIC]:
                    cmds = cmds[INDEX_GENERIC][self._model]
                elif not self._model:
                    self.logger.debug(f&#39;model set to empty string, not loading commands. You have been warned...&#39;)
                    cmds = {}
                else:
                    raise CommandsError(f&#39;commands require configuration attribute &#34;model&#34;, but model {self._model + &#34; not set in commands dict&#34; if self._model else &#34;unknown&#34;}.&#39;)
            if self._model:
                cmdlist = cmd_module.models[self._model]
                self.logger.debug(f&#39;found {len(cmdlist)} commands for model {self._model}&#39;)
                if INDEX_GENERIC in cmd_module.models:
                    cmdlist += cmd_module.models[INDEX_GENERIC]
                    self.logger.debug(f&#39;found {len(cmd_module.models[INDEX_GENERIC])} generic commands&#39;)
            if cmdlist is None:
                cmdlist = cmds.keys()
            self._parse_commands(device_id, cmds, cmdlist)
        else:
            if not MD_standalone:
                self.logger.warning(&#39;no command definitions found. This device probably will not work...&#39;)

        if hasattr(cmd_module, &#39;lookups&#39;) and isinstance(cmd_module.lookups, dict):
            self._parse_lookups(device_id, cmd_module.lookups)
        else:
            self.logger.debug(&#39;no lookups found&#39;)

        return True

    def _parse_commands(self, device_id, commands, cmds=[]):
        &#39;&#39;&#39;
        This is a reference implementation for parsing the commands dict imported
        from the commands.py file in the device subdirectory.
        For special purposes, this can be overloaded, if you want to use your
        own file format.
        &#39;&#39;&#39;
        self._commands = {}

        for cmd in cmds:
            kw = {}
            for arg in COMMAND_PARAMS:
                if arg in commands[cmd]:
                    kw[arg] = commands[cmd][arg]

            # if valid_list_ci is present in settings, convert all str elements to lowercase only once
            if &#39;settings&#39; in kw:
                if &#39;valid_list_ci&#39; in kw[&#39;settings&#39;]:
                    kw[&#39;settings&#39;][&#39;valid_list_ci&#39;] = [entry.lower() if isinstance(entry, str) else entry for entry in kw[&#39;settings&#39;][&#39;valid_list_ci&#39;]]

            dt_class = None
            dev_datatype = kw.get(&#39;dev_datatype&#39;, &#39;&#39;)
            if dev_datatype:
                class_name = &#39;&#39; if dev_datatype[:2] == &#39;DT_&#39; else &#39;DT_&#39; + dev_datatype
                dt_class = self._dt.get(class_name)

            if kw.get(&#39;read&#39;, False) and kw.get(&#39;opcode&#39;, &#39;&#39;) == &#39;&#39; and kw.get(&#39;read_cmd&#39;, &#39;&#39;) == &#39;&#39;:
                self.logger.info(f&#39;command {cmd} will not create a command for reading values. Check commands.py configuration...&#39;)
            if kw.get(&#39;write&#39;, False) and kw.get(&#39;opcode&#39;, &#39;&#39;) == &#39;&#39; and kw.get(&#39;write_cmd&#39;, &#39;&#39;) == &#39;&#39;:
                self.logger.info(f&#39;command {cmd} will not create a command for writing values. Check commands.py configuration...&#39;)
            if not dt_class:
                self.logger.error(f&#39;importing command {cmd} found invalid datatype &#34;{dev_datatype}&#34;, replacing with DT_raw. Check function of device&#39;)
                dt_class = DT.DT_raw
            self._commands[cmd] = self._cmd_class(self.device_id, cmd, dt_class, **{&#39;cmd&#39;: kw, &#39;plugin&#39;: self._plugin_params})

    def _parse_lookups(self, device_id, lookups):
        &#39;&#39;&#39;
        This is a reference implementation for parsing the lookups dict imported
        from the commands.py file in the device subdirectory.
        For special purposes, this can be overloaded, if you want to use your
        own file format.
        &#39;&#39;&#39;
        if INDEX_GENERIC in lookups:
            lu = lookups[INDEX_GENERIC]
            self.logger.debug(f&#39;found {len(lu)} generic lookup table{&#34;&#34; if len(lu) == 1 else &#34;s&#34;}&#39;)

            if self._model and self._model in lookups:
                lu.update(lookups[self._model])
                self.logger.debug(f&#39;found {len(lookups[self._model])} lookup table{&#34;&#34; if len(lookups[self._model]) == 1 else &#34;s&#34;} for model {self._model}&#39;)
        else:
            lu = lookups

        for table in lu:
            if isinstance(lu[table], dict):

                self._lookups[table] = {}

                # original dict
                self._lookups[table][&#39;fwd&#39;] = lu[table]
                # reversed dict
                self._lookups[table][&#39;rev&#39;] = {v: k for (k, v) in lu[table].items()}
                # reversed dict, keys are lowercase for case insensitive lookup
                self._lookups[table][&#39;rci&#39;] = {v.lower() if isinstance(v, str) else v: k for (k, v) in lu[table].items()}

                self._lookup_tables.append(table)
                self.logger.debug(f&#39;imported lookup table {table} with {len(lu[table])} items&#39;)
            else:
                self.logger.warning(f&#39;key {table} in lookups not in dict format, ignoring&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="multidevice.MD_Commands.MD_Commands.get_command_from_reply"><code class="name flex">
<span>def <span class="ident">get_command_from_reply</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_command_from_reply(self, data):
    if type(data) in (bytes, bytearray):
        data = str(data.decode(&#39;utf-8&#39;))

    for command in self._commands:
        tokens = getattr(self._commands[command], &#39;reply_token&#39;, None)
        if tokens:
            if not isinstance(tokens, list):
                tokens = [tokens]
            for token in tokens:
                if token == &#39;REGEX&#39; and getattr(self._commands[command], &#39;reply_pattern&#39;, None):

                    # token is &#34;REGEX&#34; - parse read_cmd as regex
                    try:
                        regex = re.compile(getattr(self._commands[command], &#39;reply_pattern&#39;))
                        if regex.match(data) is not None:
                            self.logger.debug(f&#39;matched reply_pattern {getattr(self._commands[command], &#34;reply_pattern&#34;)} as regex against data {data}, found command {command}&#39;)
                            return command
                    except Exception as e:
                        self.logger.warning(f&#39;parsing or matching reply_pattern {getattr(self._commands[command], &#34;reply_pattern&#34;)} from command {command} as regex failed. Error was: {e}. Ignoring&#39;)
                elif token != &#39;&#39; and token == data[:len(token)]:

                    # token ist just a string
                    return command
    return None</code></pre>
</details>
</dd>
<dt id="multidevice.MD_Commands.MD_Commands.get_lookup"><code class="name flex">
<span>def <span class="ident">get_lookup</span></span>(<span>self, lookup, type='fwd')</span>
</code></dt>
<dd>
<div class="desc"><p>returns the contents of the lookup table named <lookup>, None on error</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_lookup(self, lookup, type=&#39;fwd&#39;):
    &#39;&#39;&#39; returns the contents of the lookup table named &lt;lookup&gt;, None on error &#39;&#39;&#39;
    if lookup in self._lookups and type in (&#39;fwd&#39;, &#39;rev&#39;, &#39;rci&#39;):
        return self._lookups[lookup][type]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="multidevice.MD_Commands.MD_Commands.get_send_data"><code class="name flex">
<span>def <span class="ident">get_send_data</span></span>(<span>self, command, data=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_send_data(self, command, data=None, **kwargs):
    if command in self._commands:
        lu = self._get_cmd_lookup(command)
        if lu:
            data = self._lookup(data, lu, rev=True)
        return self._commands[command].get_send_data(data, **kwargs)

    raise Exception(f&#39;command {command} not found in commands&#39;)</code></pre>
</details>
</dd>
<dt id="multidevice.MD_Commands.MD_Commands.get_shng_data"><code class="name flex">
<span>def <span class="ident">get_shng_data</span></span>(<span>self, command, data, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_shng_data(self, command, data, **kwargs):
    if command in self._commands:
        result = self._commands[command].get_shng_data(data, **kwargs)
        lu = self._get_cmd_lookup(command)
        if lu:
            result = self._lookup(result, lu)
        return result

    raise Exception(f&#39;command {command} not found in commands&#39;)</code></pre>
</details>
</dd>
<dt id="multidevice.MD_Commands.MD_Commands.is_valid_command"><code class="name flex">
<span>def <span class="ident">is_valid_command</span></span>(<span>self, command, read=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_valid_command(self, command, read=None):
    if command not in self._commands:
        return False

    if read is None:
        return True

    # if the corresponding attribute is not defined, assume False (fail safe)
    return getattr(self._commands[command], &#39;read&#39; if read else &#39;write&#39;, False)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="multidevice" href="index.html">multidevice</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="multidevice.MD_Commands.MD_Commands" href="#multidevice.MD_Commands.MD_Commands">MD_Commands</a></code></h4>
<ul class="">
<li><code><a title="multidevice.MD_Commands.MD_Commands.get_command_from_reply" href="#multidevice.MD_Commands.MD_Commands.get_command_from_reply">get_command_from_reply</a></code></li>
<li><code><a title="multidevice.MD_Commands.MD_Commands.get_lookup" href="#multidevice.MD_Commands.MD_Commands.get_lookup">get_lookup</a></code></li>
<li><code><a title="multidevice.MD_Commands.MD_Commands.get_send_data" href="#multidevice.MD_Commands.MD_Commands.get_send_data">get_send_data</a></code></li>
<li><code><a title="multidevice.MD_Commands.MD_Commands.get_shng_data" href="#multidevice.MD_Commands.MD_Commands.get_shng_data">get_shng_data</a></code></li>
<li><code><a title="multidevice.MD_Commands.MD_Commands.is_valid_command" href="#multidevice.MD_Commands.MD_Commands.is_valid_command">is_valid_command</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>